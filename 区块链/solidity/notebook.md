# 合约结构

每个合约中可以包含`状态变量`，`函数`，`事件Event`，`错误（Error）`，`结构体`和`枚举类型`的声明，且合约可以从其他合约继承。

还有一些特殊的合约，比如：`库`和`接口`

## 状态变量

状态变量是永久地储存在合约储存中的值

### 类型

Solidity 是静态类型语言，这意味着每一个变量（状态变量和局部变量）都需要在编译时指定变量类型。

Solidity 提供了几种基本类型，并且基本类型可以用来组合出复杂类型。

除此之外，类型之间可以包含在运算符号的表达式中进行交互。

`undefined`和`null`在 Solidity 中不存在，但是新声明的变量总是有一个默认值，具体的默认值跟类型相关。要处理任何意外的值，应该使用`错误处理`来恢复整个交易，或者返回一个带有第二个`bool`值的元组表示成功

#### 值类型

以下类型也成为值类型，因为这些类型的变量将始终按值来传递。也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行拷贝

##### 布尔类型

`bool`：可能的取值为字面常值`true`和`false`
运算符：

- `!`（逻辑非）
- `&&`（逻辑与）
- `||`（逻辑或）
- `==`（逻辑等于）
- `!=`（逻辑不等于）
  运算符`||` 和 `&&` 都遵循同样的短路规则。

##### 整型

`int`/`uint`：分别表示有符号和无符号的不同位数的整型变量。支持关键字`uint8`和`uint256`（无符号，从 8 位到 256 位）以及`int8`到`int256`，以`8`位为步长递增。`uint`和`int`分别是`uint256`和`int256`的别名。

运算符：

- 比较运算符：`<=`，`<`，`==`，`!=`，`>=`，`>`（返回布尔值）
- 位运算符：`&`，`|`，`^`（异或），`~`（位取反）
- 移位运算符：`<<`（左移位），`>>`（右移位）
- 算数运算符：`+`，`-`，一元运算负`-`（仅针对有符号整型），`*`，`/`，`%`（取余），`**`（幂）

对于整型`X`，可以使用`type(X).min` 和 `type(X).max`去获取这个类型的最小值与最大值

##### 地址类型 Address

地址类型有两种类型，他们大致相同：

- address：保存一个 20 字节的值（以太坊地址的大小）
- address payable：可支付地址，与`address`相同，不过有成员函数`transfer`和`send`。
  这种区别背后的思想是`address payable`可以发送以太币，而不能像一个普通的`address`接受以太币。例如，它可能是一个智能合约地址，并且不支持接受以太币。

**_类型转换：_**
允许从`address payable`到`address`的隐式转换，而从`address`到`address payable`必须显示的转换，通过`payable(<address>)`进行转换。
`address`允许和`unit160`、`整型字面常量`、`bytes20`及`合约类型`相互转换
只能通过`payable(...)`表达式把`address`类型和合约类型转换为`address payable`。只有能接收以太币的合约类型，才能够进行此转换。例如，合约要么有`receive`或可支付的回退函数。注意：`payable(0)`是有效的，这是此规则的例外。

###### 地址类型成员变量

- `balance`：可以用`balance`属性来查询一个地址的余额
- `transfer`：使用`transfer`方法向一个可支付地址发送以太币
- `send`：`send`是`transfer`的低级版本。如果执行失败，当期合约不会因为异常而终止，但`send`会返回`false`。
- `call`，`delegatecall`，`staticcall`：为了与不符合引用二进制接口的合约交互，或者要更直接地控制编码，提供了函数`call`，`delegatecall`，`staticcall`。它们都带有一个`betys memory`参数和返回执行成功状态（`bool`）和数据（`betys memory`）

函数`abi.encode`，`abi.encodePacked`，`abi.encodeWithSelector`和`abi.encodeWithSignature`可用于编码结构化数据。

```sol
//x是一个合约地址
address x = 0x123;
address myAddress = this;
if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);
```

##### 合约类型

每一个`contract`定义都有他自己的类型。
您可以隐式地将合约转换为从他们继承的合约。合约可以显示转换为`address`类型。
只有当合约具有接受`receive`函数或`payable`回退函数时，才能显式和`address payable`类型相互转换，转换仍然使用`address(x)`执行，如果合约类型没有接收或`payable`回退功能，则可以使用`payable(address(x))`转换为`address payable`

- 如果声明一个合约类型的局部变量（MyContract c），则可以调用该合约的函数。注意需要赋相同合约类型的值给它。
- 您还可以实例化合约（即新创建一个合约对象）
- 合约和`address`的数据表示是相同的
- 合约不支持任何运算符
- 合约类型的成员是合约的外部函数及`public`的状态变量
- 对于合约`C`可以使用`type(C)`获取合约的类型信息

##### 定长字节数组

关键字有：`bytes1`，`bytes2`，`byte3`，……，`bytes32`
成员属性:

- `length`：表示这个字节数组的长度（只读）

##### 变长字节数组
- `bytes`：变长字节数组，它并不是值类型
- `string`：变长`UTF-8`编码字符串类型，它并不是值类型

##### 地址字面常量
比如：像`0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`这样的通过了地址校验和测试的十六进制字面常量会作为`address`类型。而没有通过校验测试，长度在39到41个数字之间的十六进制字面常量，会产生一个错误，您可以在零前面添加（对于整数类型）或在零后面添加（对于bytesNN类型）以消除错误。

##### 有理数和整数字面常量
整数字面常量由范围在`0-9`的一串数字组成，表现成十进制。例如：69表示数字69。Solidity中是没有八进制的，因此前置0是无效的。

十进制小数字面常量带有一个`.`，至少在其一边会有一个数字。比如：`1`，`.1`和`1.3`
`2e10`形式的科学符号也是支持的，尽管指数必须是整数，但底数可以是小数，`MeE`的值`M * 10**E`。

为了提高可读性可以在数字之间加上下划线。例如，十进制`123_000`，十六进制`0x2eff_abde`，科学十进制表示`1_2e345_678 `都是有效的。下划线仅允许在两位数之间，并且不允许下划线连续出现。添加到数字文字中的下划线没有额外的语义，下划线会被编译器忽略。

##### 字符串字面量及类型
字符串字面常量是指由双引号或单引号引起来的字符串（"foo"或'bar'）。它们也可以分为多个连续的部分（"foo""bar"等效于"foobar"），这在处理长字符串时很有用。不像在C语言中那样带有结束符；"foo"相当于3个字节而不是4个。和整数字面量一样，字符串字面常量的类型也可以发生改变，
但它们可以隐式地转换成`bytes1`，……，`bytes32`，如果合适的话，还可以转换成`bytes`以及`string`

##### Unicode字面常量
常规字符串文字只能包含ASCⅡ，而Unicode文字（以关键字`unicode`为前缀）可以包含任何有效的UTF-8序列。它们还支持与转义序列完全相同的字符作为常规字符串文字。


##### 十六进制字面常量
十六进制字面常量以关键字`hex`打头，后面紧跟着用单引号或双引号引起来的字符串（例如：hex"001122ff"）。字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。

它们的内容必须是十六进制数字，可以选择使用单个下划线作为字节边界分隔符。字面常量的值将是十六进制序列的二进制表示形式。

用空格分隔的多个十六进制字面常量被合并为一个字面常量`hex"00112233" hex("44556677")`等同于`hex("0011223344556677")`

十六进制字面常量跟`字符串字面常量`很类似，具有相同的转换规则

##### 枚举类型



## 函数

函数是代码的可执行单元。函数通常在合约内部定义，但也可以在合约外定义。
函数调用可发生在合约内部或外部，且函数对其他合约有不同程度的可见性
函数可以接受参数和返回值

## 函数修改器

函数修改器（`modifier`）可以用来以声明的方式修改函数语义
重载，表示有同样的修改器名称但是有不同的参数的情况，<del>这是不允许的。</del>

## 事件 Event

事件是能方便地调用以太坊虚拟机日志功能的接口。

## 错误（Error）

Solidity 为应对失败，允许用户定义`error`来描述错误的名称和数据。错误可以在`revert statement`中使用，
跟用错误字符串相比，`error`更便宜并且允许你编码额外的数据，还可以用`NatSpec`为用户去描述错误。

## 结构体

结构体是可以将几个变量分组的自定义类型

## 枚举类型

枚举可用来创建由一定数量的`常量值`构成的自定义类型
