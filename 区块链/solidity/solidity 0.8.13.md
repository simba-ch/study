# åŸºç¡€

## æ™ºèƒ½åˆçº¦å…¥é—¨

## å®‰è£… solidity ç¼–è¯‘å™¨

## æ ¹æ®ä¾‹å­å­¦ä¹  Solidity

# SOLIDITY è¯¦è§£

## Solidity æºæ–‡ä»¶ç»“æ„

æºæ–‡ä»¶å¯ä»¥åŒ…å«*ä»»æ„æ•°é‡*çš„**åˆçº¦å®šä¹‰**ï¼Œ**æºæ–‡ä»¶å¼•å…¥**ï¼Œ**pragma**ã€**using for**æŒ‡ä»¤å’Œ**struct**ï¼Œ**enum**ï¼Œ**function**ï¼Œ**error**ä»¥åŠ**å¸¸é‡å®šä¹‰**

### SPDX ç‰ˆæƒè®¸å¯æ ‡è¯†

å¦‚ä¸‹ï¼šåœ¨æºæ–‡ä»¶çš„é¡¶éƒ¨ï¼Œä½¿ç”¨`SPDX-License-Identifier:`åŠ æ”¯æŒçš„[SPDX è®¸å¯æ ‡è¯†](https://spdx.org/licenses/)ï¼Œæ¥è¯´æ˜å…¶ç‰ˆæƒçš„è®¸å¯è¯
`UNLICENSEN`ï¼šå¦‚æœä½ ä¸æƒ³æŒ‡å®šä¸€ä¸ªè®¸å¯è¯ï¼Œæˆ–å¦‚æœæºä»£ç ä¸å¼€æºï¼Œè¯·ä½¿ç”¨è¿™ä¸ªç‰¹æ®Šçš„æ ‡è¯†ç¬¦ã€‚**è¯·æ³¨æ„ï¼š**`UNLICENSEN`ï¼ˆä¸å­˜åœ¨ä¸ SPDX è®¸å¯è¯åˆ—è¡¨ä¸­ï¼‰ä¸`UNLICENSE`ï¼ˆæˆäºˆæ‰€æœ‰äººæ‰€æœ‰æƒï¼‰ä¸åŒ

```sol
// SPDX-License-Identifier: MIT
```

### Pragmas å’Œç‰ˆæœ¬æ ‡è¯†

`pragma`ï¼šå…³é”®å­—ï¼Œé…åˆæ ‡è¯†ç¬¦æ¥å‘Šè¯‰ç¼–è¯‘å™¨ä¸€äº›é¢å¤–ä¿¡æ¯
æ ‡è¯†ç¬¦ï¼š

- `solidity`åŠ ç‰ˆæœ¬å·è¡¨ç¤ºå½“å‰æ–‡ä»¶çš„ä½¿ç”¨çš„ solidity å“ªä¸ªç‰ˆæœ¬çš„è¯­æ³•è§„åˆ™ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨ç”¨æŒ‡å®šçš„ç‰ˆæœ¬å»ç¼–è¯‘æ–‡ä»¶
- `experimental`æ¥è¡¨ç¤ºå¯ç”¨ä¸€äº›æ–°çš„ç¼–è¯‘å™¨çš„åŠŸèƒ½æˆ–è¯­æ³•ç‰¹æ€§ï¼ˆé€šå¸¸éƒ½æ˜¯å®éªŒæ€§è´¨çš„ï¼Œæ²¡æœ‰æœ€ç»ˆæˆä¸ºæ ‡å‡†ï¼Œéšæ—¶å¯èƒ½è¢«åºŸå¼ƒï¼‰
  ç‰ˆæœ¬å·ï¼š`0.x.0`æˆ–è€… `x.0.0`

- é¿å…äº†ä»¥åç‰ˆæœ¬å‡ºç°ä¸å…¼å®¹çš„æ›´æ–°ï¼Œæ–‡ä»¶ç¼–è¯‘æŠ¥é”™
- ç‰ˆæœ¬æ ‡è¯†é€šå¸¸åªå¯¹æœ¬æ–‡ä»¶æœ‰æ•ˆ
- å¦‚æœå¼•å…¥äº†å…¶ä»–æ–‡ä»¶ï¼Œæ ‡è¯†å¹¶ä¸ä¼šä»è¢«å¯¼å…¥çš„æ–‡ä»¶ï¼ŒåŠ å…¥åˆ°å¯¼å…¥æ–‡ä»¶ä¸­

```sol
//å½“å‰æ–‡ä»¶åªå…è®¸é«˜äº0.4.0å¹¶ä¸”ä½äº0.9.0çš„ç¼–è¯‘å™¨ç¼–è¯‘
pragma solidity >=0.4.0 <0.9.0
//å¼€å¯SMT solver é¢å¤–çš„å®‰å…¨æ£€æŸ¥
pragma experimental SMTChecker
```

### å¯¼å…¥å…¶ä»–æºæ–‡ä»¶

filename:æ˜¯å¯¼å…¥è·¯å¾„
å¯¼å…¥è·¯å¾„ï¼š

```sol
//ä¸‹é¢åˆ›å»ºäº†æ–°çš„symbolNameå…¨å±€ç¬¦å·ï¼Œå®ƒçš„æˆå‘˜éƒ½æ¥è‡ªå¯¼å…¥çš„filenameæ–‡ä»¶ä¸­çš„å…¨å±€ç¬¦å·
import 'filename' as symbolName
//å¦‚æœå­˜åœ¨å‘½åå†²çªï¼Œå¯ä»¥åœ¨å¯¼å…¥æ—¶é‡å‘½å
import {symbol1 as alias,symbol2} from 'filename'
```

### æ³¨é‡Š

å¯ä»¥ä½¿ç”¨å•è¡Œæ³¨é‡Š`//`å’Œå¤šè¡Œæ³¨é‡Š`/*...*/`
æ­¤å¤–ï¼Œæœ‰å¦ä¸€ç§æ³¨é‡Šç§°ä¸º NatSpec æ³¨é‡Šï¼ŒNatSpec æ³¨é‡Šä½¿ç”¨`///`æˆ–`**`æ³¨é‡Šï¼Œåº”è¯¥ç›´æ¥åœ¨å‡½æ•°å£°æ˜å’Œè¯­å¥ä¸Šæ–¹ä½¿ç”¨

```sol
// è¿™æ˜¯ä¸€ä¸ªå•è¡Œæ³¨é‡Šã€‚

/*
è¿™æ˜¯ä¸€ä¸ª
å¤šè¡Œæ³¨é‡Šã€‚
*/
```

## åˆçº¦ç»“æ„

åœ¨ Solidity è¯­è¨€ä¸­ï¼Œåˆçº¦ç±»ä¼¼äºå…¶ä»–é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ä¸­çš„ **_ç±»_**
æ¯ä¸ªåˆçº¦ä¸­å¯ä»¥åŒ…å«**çŠ¶æ€å˜é‡**ã€**å‡½æ•°**ã€**å‡½æ•°ä¿®æ”¹å™¨ï¼ˆmodifierï¼‰**ã€**äº‹ä»¶ Event**ï¼Œ**é”™è¯¯ Errors**ã€**ç»“æ„ä½“**å’Œ**æšä¸¾ç±»å‹**çš„å£°æ˜ï¼Œä¸”åˆçº¦å¯ä»¥ä»å…¶ä»–åˆçº¦ç»§æ‰¿

è¿˜æœ‰ä¸€äº›ç‰¹æ®Šçš„åˆçº¦ï¼Œå¦‚ï¼š**åº“** å’Œ **æ¥å£**

### çŠ¶æ€å˜é‡

çŠ¶æ€å˜é‡æ˜¯å¯ä»¥æ°¸ä¹…çš„å‚¨å­˜åœ¨åˆçº¦å‚¨å­˜ä¸­çš„å€¼

```sol
pragma solidity >=0.4.0 <0.9.0;

contract TinyStorage {
    uint storedXlbData; // çŠ¶æ€å˜é‡
    // ...
}

```

### å‡½æ•°

å‡½æ•°æ˜¯ä»£ç çš„å¯æ‰§è¡Œå•ä½ã€‚å‡½æ•°é€šå¸¸åœ¨åˆçº¦å†…éƒ¨å®šä¹‰ï¼Œä½†ä¹Ÿå¯ä»¥åœ¨åˆçº¦å¤–å®šä¹‰
å‡½æ•°è°ƒç”¨å¯å‘ç”Ÿåœ¨åˆçº¦å†…éƒ¨æˆ–å¤–éƒ¨ï¼Œä¸”å‡½æ•°å¯¹å…¶ä»–åˆçº¦æœ‰ä¸åŒç¨‹åº¦çš„å¯è§æ€§ï¼ˆå¯è§æ€§å’Œ getter å‡½æ•°ï¼‰
å‡½æ•°å¯ä»¥æ¥å—å‚æ•°å’Œè¿”å›å€¼

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.1 <0.9.0;

contract TinyAuction {
    function Mybid() public payable { // å®šä¹‰å‡½æ•°
        // ...
    }
}

// Helper function defined outside of a contract
function helper(uint x) pure returns (uint) {
    return x * 2;
}
```

### å‡½æ•°ä¿®æ”¹å™¨ï¼ˆmodifierï¼‰

å‡½æ•°ä¿®æ”¹å™¨ï¼ˆmodifierï¼‰å¯ä»¥ç”¨æ¥ä»¥å£°æ˜çš„æ–¹å¼ä¿®æ”¹å‡½æ•°çš„è¯­ä¹‰
é‡è½½ï¼ˆOverloadingï¼‰ï¼Œè¡¨ç¤ºæœ‰åŒæ ·çš„ä¿®æ”¹å™¨ï¼ˆmodifierï¼‰åç§°ä½†æ˜¯æœ‰ä¸åŒçš„å‚æ•°çš„æƒ…å†µï¼Œè¿™æ˜¯ä¸å…è®¸çš„ã€‚
è€Œä¾‹å¦‚å‡½æ•°æˆ–ä¿®æ”¹å™¨åˆ™å¯ä»¥è¢«é‡å†™ï¼ˆoverriddenï¼‰

```sol
pragma solidity >=0.4.22 <0.9.0;

contract MyPurchase {
    address public seller;

    modifier onlySeller() { // ä¿®æ”¹å™¨
        require(
            msg.sender == seller,
            "Only seller can call this."
        );
        _;
    }

    function abort() public onlySeller { // ä¿®æ”¹å™¨ç”¨æ³•
        // ...
    }
}
```

### äº‹ä»¶ Event

äº‹ä»¶æ˜¯èƒ½æ–¹ä¾¿çš„è°ƒç”¨ä»¥å¤ªåŠè™šæ‹Ÿæœºæ—¥å¿—åŠŸèƒ½çš„æ¥å£

```sol
pragma solidity >=0.4.21 <0.9.0;
contract TinyAuction {
    event HighestBidIncreased(address bidder, uint amount); // äº‹ä»¶

    function bid() public payable {
        // ...
        emit HighestBidIncreased(msg.sender, msg.value); // è§¦å‘äº‹ä»¶
    }
}
```

### é”™è¯¯ Errors

Solidity ä¸ºåº”å¯¹å¤±è´¥ï¼Œå…è®¸ç”¨æˆ·å®šä¹‰`error`æ¥æè¿°é”™è¯¯çš„åç§°å’Œæ•°æ®ã€‚é”™è¯¯å¯ä»¥åœ¨`revert statements`ä¸­ä½¿ç”¨ï¼Œ
è·Ÿç”¨é”™è¯¯å­—ç¬¦ä¸²ç›¸æ¯”ï¼Œ`error`æ›´ä¾¿å®œå¹¶ä¸”å…è®¸ä½ ç¼–ç é¢å¤–çš„æ•°æ®ï¼Œè¿˜å¯ä»¥ç”¨ NatSpec ä¸ºç”¨æˆ·å»æè¿°é”™è¯¯

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

/// æ²¡æœ‰è¶³å¤Ÿçš„èµ„é‡‘ç”¨äºè½¬è´¦ï¼Œ å‚æ•° `requested` è¡¨ç¤ºéœ€è¦çš„èµ„é‡‘ï¼Œ`available` è¡¨ç¤ºä»…æœ‰çš„èµ„é‡‘ã€‚

error NotEnoughFunds(uint requested, uint available);

contract Token {
    mapping(address => uint) balances;
    function transfer(address to, uint amount) public {
        uint balance = balances[msg.sender];
        if (balance < amount)
            revert NotEnoughFunds(amount, balance);
        balances[msg.sender] -= amount;
        balances[to] += amount;
        // ...
    }
}
```

### ç»“æ„ä½“

ç»“æ„ä½“æ˜¯å¯ä»¥å°†å‡ ä¸ªå˜é‡åˆ†ç»„çš„è‡ªå®šä¹‰ç±»å‹

```sol
pragma solidity >=0.4.0 <0.9.0;

contract TinyBallot {
    struct Voter { // ç»“æ„ä½“
        uint weight;
        bool voted;
        address delegate;
        uint vote;
    }
}
```

### æšä¸¾ç±»å‹

æšä¸¾å¯ç”¨æ¥åˆ›å»ºç”±ä¸€å®šæ•°é‡çš„**å¸¸é‡å€¼**æ„æˆçš„è‡ªå®šä¹‰ç±»å‹

```sol
pragma solidity >=0.4.0 <0.9.0;

contract Upchain {
    enum State { Created, Locked, InValid } // æšä¸¾
}

```

## ç±»å‹

Solidity æ˜¯ä¸€ç§é™æ€ç±»å‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªå˜é‡ï¼ˆçŠ¶æ€å˜é‡å’Œå±€éƒ¨å˜é‡ï¼‰éƒ½éœ€è¦åœ¨ç¼–è¯‘æ—¶æŒ‡å®šå˜é‡çš„ç±»å‹
Solidity æä¾›äº†å‡ ç§åŸºæœ¬ç±»å‹ï¼Œå¹¶ä¸”åŸºæœ¬ç±»å‹å¯ä»¥ç”¨æ¥ç»„åˆå‡ºå¤æ‚ç±»å‹
é™¤æ­¤ä¹‹å¤–ï¼Œç±»å‹ä¹‹é—´å¯ä»¥åœ¨åŒ…å«è¿ç®—ç¬¦å·çš„è¡¨è¾¾å¼ä¸­è¿›è¡Œäº¤äº’ã€‚
`undefined` å’Œ `null`å€¼çš„æ¦‚å¿µåœ¨ Solidity ä¸­ä¸å­˜åœ¨ï¼Œä½†æ˜¯æ–°å£°æ˜çš„å˜é‡æ€»æœ‰ä¸€ä¸ªé»˜è®¤å€¼ï¼Œå…·ä½“çš„é»˜è®¤å€¼è·Ÿç±»å‹ç›¸å…³ã€‚
è¦å¤„ç†ä»»ä½•æ„å¤–çš„å€¼ï¼Œåº”è¯¥ä½¿ç”¨é”™è¯¯å¤„ç†æ¥æ¢å¤æ•´ä¸ªäº¤æ˜“ï¼Œæˆ–è€…è¿”å›ä¸€ä¸ªå¸¦æœ‰ç¬¬äºŒä¸ª`bool`å€¼çš„å…ƒç»„è¡¨ç¤ºæˆåŠŸ

### å€¼ç±»å‹

ä»¥ä¸‹ç±»å‹ä¹Ÿæˆä¸ºå€¼ç±»å‹ï¼Œå› ä¸ºè¿™äº›ç±»å‹çš„å˜é‡å°†å§‹ç»ˆæŒ‰å€¼æ¥ä¼ é€’ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“è¿™äº›å˜é‡è¢«ç”¨ä½œå‡½æ•°å‚æ•°æˆ–è€…ç”¨åœ¨èµ‹å€¼è¯­å¥ä¸­æ—¶ï¼Œæ€»ä¼šè¿›è¡Œå€¼æ‹·è´ã€‚

- å¸ƒå°”ç±»å‹ï¼ˆboolï¼‰ï¼šå¯èƒ½å–å€¼ä¸ºå­—é¢å¸¸é‡`true` å’Œ `false`
- æ•´å‹ï¼ˆint / uintï¼‰ï¼šåˆ†åˆ«è¡¨ç¤ºæœ‰ç¬¦å·å’Œæ— ç¬¦å·çš„ä¸åŒçš„ä½æ•°çš„æ•´å‹å˜é‡ã€‚æ”¯æŒå…³é”®å­—`uint8`åˆ°`uint256`(æ— ç¬¦å·ï¼Œä» 8 ä½åˆ° 256 ä½)ä»¥åŠ`int8`åˆ°`int256`ï¼Œä»¥`8`ä½ä¸ºæ­¥é•¿é€’å¢ã€‚`uint` å’Œ `int`åˆ†åˆ«æ˜¯`uint256`å’Œ `int256`çš„åˆ«åã€‚å¯¹äºæ•´å‹`X`ï¼Œå¯ä»¥ä½¿ç”¨`type(X).min`å’Œ`type(X).max`å»è·å–è¿™æ˜¯ç±»å‹çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚
- å®šé•¿æµ®ç‚¹å‹ï¼ˆfixed / ufixedï¼‰ï¼šè¡¨ç¤ºå„ç§å¤§å°çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·çš„å®šé•¿æµ®ç‚¹å‹ã€‚åœ¨å…³é”®å­—`ufixedMxN` å’Œ `fixedMxN`ä¸­ï¼Œ`M`è¡¨ç¤ºè¯¥ç±»å‹å ç”¨çš„ä½æ•°ï¼Œ`N`è¡¨ç¤ºå¯ç”¨çš„å°æ•°ä½æ•°ã€‚`M`å¿…é¡»èƒ½æ•´é™¤ 8ï¼Œå³ 8 åˆ° 256 ä½ã€‚`N`åˆ™å¯ä»¥æ˜¯ä» 0 åˆ° 80 ä¹‹é—´çš„ä»»æ„æ•°ã€‚`ufixed`å’Œ `fixed`åˆ†åˆ«æ˜¯`ufixed128x19`å’Œ`fixed128x19`çš„åˆ«åã€‚
- åœ°å€ç±»å‹ï¼ˆaddressï¼‰ï¼š
  åœ°å€ç±»å‹æœ‰ä¸¤ç§å½¢å¼ï¼Œå®ƒä»¬å¤§è‡´ç›¸åŒï¼š
  - `address`ï¼šä¿å­˜ä¸€ä¸ª 20 å­—èŠ‚çš„å€¼ï¼ˆä»¥å¤ªåŠåœ°å€çš„å¤§å°ï¼‰
  - `address payable`ï¼šå¯æ”¯ä»˜åœ°å€ï¼Œä¸`address`ç›¸åŒï¼Œä¸è¿‡æœ‰æˆå‘˜å‡½æ•°`transfer` å’Œ `send`ã€‚å¯ä»¥å‘è¯¥åœ°å€å‘é€ä»¥å¤ªå¸
    å…è®¸ä»`address payable` åˆ° `address` çš„éšå¼è½¬æ¢ï¼Œè€Œä»`address` åˆ° `address payable`å¿…é¡»æ˜¾å¼çš„è½¬æ¢ï¼Œé€šè¿‡`payable(address)`è¿›è¡Œè½¬æ¢ã€‚
    åœ°å€ç±»å‹æˆå‘˜ï¼š
    - `balance`å±æ€§ï¼šå¯ä»¥ä½¿ç”¨`balance`å±æ€§æŸ¥è¯¢ä¸€ä¸ªåœ°å€çš„ä½™é¢
    - `transfer`æ–¹æ³•ï¼šä½¿ç”¨`transfer`æ–¹æ³•å‘ä¸€ä¸ªå¯æ”¯ä»˜çš„åœ°å€å‘é€ä»¥å¤ªå¸
    - `call`ï¼Œ`delegatecall`ï¼Œ`staticcall`ï¼šä¸ºäº†ä¸ä¸ç¬¦åˆåº”ç”¨äºŒè¿›åˆ¶æ¥å£çš„åˆçº¦äº¤äº’ï¼Œæˆ–è€…è¦æ›´ç›´æ¥çš„æ§åˆ¶ç¼–ç ï¼Œæä¾›äº†å‡½æ•°`call`ï¼Œ`delegatecall`å’Œ `staticcall`ã€‚å®ƒä»¬éƒ½å¸¦æœ‰ä¸€ä¸ª`betys memory`å‚æ•°å’Œè¿”å›æ‰§è¡ŒæˆåŠŸçŠ¶æ€ï¼ˆ`bool`ï¼‰å’Œæ•°æ®ï¼ˆ`betys memory`ï¼‰ã€‚å…¶ä¸­ï¼Œ`call`å¯ä»¥æ¥å—ä»»æ„ç±»å‹ï¼Œä»»æ„æ•°é‡çš„å‚æ•°ï¼Œè¿™äº›å‚æ•°ä¼šè¢«æ‰“åŒ…åˆ°ä»¥ 32 å­—èŠ‚ä¸ºå•ä½çš„è¿ç»­çš„åŒºåŸŸä¸­å­˜æ”¾ã€‚å…¶ä¸­ä¸€ä¸ªä¾‹å¤–æ˜¯å½“ç¬¬ä¸€ä¸ªå‚æ•°è¢«ç¼–ç æˆæ­£å¥½ 4 ä¸ªå­—èŠ‚çš„æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™ä¸ªå‚æ•°åè¾¹ä¸ä¼šå¡«å……åç»­å‚æ•°ç¼–ç ï¼Œä»¥å…è®¸ä½¿ç”¨å‡½æ•°ç­¾åã€‚
    ```sol
      bytes memory payload = abi.encodeWithSignature("register(string)", "MyName");
      (bool success, bytes memory returnData) = address(nameReg).call(payload);
      require(success);
    ```
    - `code`ï¼Œ`codehash`ï¼šä½ å¯ä»¥æŸ¥è¯¢ä»»ä½•æ™ºèƒ½åˆçº¦çš„éƒ¨ç½²ä»£ç ã€‚ä½¿ç”¨`.code`æ¥è·å– EVM çš„å­—èŠ‚ç ï¼Œå…¶è¿”å›`betys memory`ï¼Œå€¼å¯èƒ½æ˜¯ç©ºã€‚ä½¿ç”¨`.codehash`è·å¾—è¯¥ä»£ç çš„ Keccak-256 å“ˆå¸Œå€¼ï¼ˆä¸º`bytes32`ï¼‰ã€‚æ³¨æ„ï¼Œ`addr.codehash`æ¯”ä½¿ç”¨`Keccak256(addr.code)`æ›´ä¾¿å®œã€‚
- åˆçº¦ç±»å‹ï¼š
  æ¯ä¸€ä¸ª contract å®šä¹‰éƒ½æœ‰å®ƒè‡ªå·±çš„ç±»å‹ã€‚
  æ‚¨å¯ä»¥éšå¼çš„å°†åˆçº¦è½¬æ¢ä¸ºä»å®ƒä»¬ç»§æ‰¿çš„åˆçº¦ã€‚
  åˆçº¦å¯ä»¥æ˜¾å¼è½¬æ¢ä¸º`address`ç±»å‹ã€‚
  åªæœ‰å½“åˆçº¦å…·æœ‰æ¥æ”¶ receive å‡½æ•°æˆ– payable å›é€€å‡½æ•°æ—¶ï¼Œæ‰èƒ½æ˜¾å¼å’Œ`address payable`ç±»å‹ç›¸äº’è½¬æ¢ï¼Œè½¬æ¢ä»ç„¶ä½¿ç”¨`address(x)`æ‰§è¡Œï¼Œå¦‚æœåˆçº¦ç±»å‹æ²¡æœ‰æ¥æ”¶æˆ– payable å›é€€åŠŸèƒ½ï¼Œåˆ™å¯ä»¥ä½¿ç”¨`payable(address(x))`è½¬æ¢ä¸º`address payable`
  å¦‚æœå£°æ˜ä¸€ä¸ªåˆçº¦ç±»å‹çš„å±€éƒ¨å˜é‡ï¼ˆ`MyContract c`ï¼‰ï¼Œåˆ™å¯ä»¥è°ƒç”¨åˆçº¦çš„å‡½æ•°ã€‚æ³¨æ„éœ€è¦èµ‹ç›¸åŒåˆçº¦ç±»å‹çš„å€¼ç»™å®ƒ
  æ‚¨è¿˜å¯ä»¥å®ä¾‹åŒ–åˆçº¦ï¼ˆå³æ–°åˆ›å»ºä¸€ä¸ªåˆçº¦å¯¹è±¡ï¼‰ã€‚
  åˆçº¦å’Œ`address`çš„æ•°æ®è¡¨ç¤ºæ˜¯ç›¸åŒçš„ã€‚
  åˆçº¦ä¸æ”¯æŒä»»ä½•è¿ç®—ç¬¦
  åˆçº¦ç±»å‹çš„æˆå‘˜æ˜¯åˆçº¦çš„å¤–éƒ¨å‡½æ•°åŠ public çš„çŠ¶æ€å˜é‡
  å¯¹äºåˆçº¦`C`å¯ä»¥ä½¿ç”¨`type(C)`è·å–åˆçº¦çš„ç±»å‹ä¿¡æ¯
- å®šé•¿å­—èŠ‚æ•°ç»„ï¼š
  å…³é”®å­—ï¼š`bytes1`ï¼Œ`betys2`ï¼Œ`betys3`ï¼Œâ€¦â€¦ï¼Œ`bytes32`
  æˆå‘˜ï¼š
  `length`å±æ€§ï¼šè¡¨ç¤ºè¿™ä¸ªå­—èŠ‚æ•°ç»„çš„é•¿åº¦ï¼ˆåªè¯»ï¼‰
- å˜é•¿å­—èŠ‚æ•°ç»„ï¼š
  `bytes`ï¼šå˜é•¿å­—èŠ‚æ•°ç»„ï¼Œå®ƒå¹¶ä¸æ˜¯å€¼ç±»å‹
  `string`ï¼šå˜é•¿ UTF-8 ç¼–ç å­—ç¬¦ä¸²ç±»å‹ï¼Œå®ƒå¹¶ä¸æ˜¯å€¼ç±»å‹
- åœ°å€å­—é¢å¸¸é‡ï¼šç±»ä¼¼äº`0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF`è¿™ç§é€šè¿‡åœ°å€æ ¡éªŒå’Œæµ‹è¯•çš„å­—é¢é‡å°±æ˜¯åœ°å€å­—é¢å¸¸é‡
- æœ‰ç†æ•°å’Œæ•´æ•°å­—é¢å¸¸é‡ï¼š
- å­—ç¬¦ä¸²å­—é¢å¸¸é‡åŠç±»å‹ï¼šå­—ç¬¦ä¸²å­—é¢å¸¸é‡æ˜¯æŒ‡ç”±åŒå¼•å·æˆ–å•å¼•å·å¼•èµ·æ¥çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²å­—é¢å¸¸é‡åªèƒ½åŒ…å«å¯æ‰“å°çš„ ASCII å­—ç¬¦ã€‚å®ƒä»¬å¯ä»¥éšå¼çš„è½¬æ¢æˆ`betys1`ï¼Œâ€¦â€¦ï¼Œ`betys32`ï¼Œå¦‚æœåˆé€‚çš„è¯ï¼Œè¿˜å¯ä»¥è½¬æ¢æˆ`betys`ä»¥åŠ`string`ã€‚
- Unicode å­—é¢å¸¸é‡ï¼šå¸¸è§„å­—ç¬¦ä¸²æ–‡å­—åªèƒ½åŒ…å« ASCIIï¼Œè€Œ Unicode æ–‡å­—ï¼ˆä»¥å…³é”®å­— unicode ä¸ºå‰ç¼€ï¼‰å¯ä»¥åŒ…å«ä»»ä½•æœ‰æ•ˆçš„ UTF-8 åºåˆ—ã€‚å®ƒä»¬è¿˜æ”¯æŒä¸è½¬ä¹‰åºåˆ—å®Œå…¨ç›¸åŒçš„å­—ç¬¦ä½œä¸ºå¸¸è§„å­—ç¬¦ä¸²æ–‡å­—ã€‚

```sol
string memory a = unicode"Hello ğŸ˜ƒ";
```

- åå…­è¿›åˆ¶å­—é¢å¸¸é‡ï¼šåå…­è¿›åˆ¶å­—é¢å¸¸é‡ä»¥å…³é”®å­—`hex`æ‰“å¤´ï¼Œåé¢ç´§è·Ÿç€ç”¨å•å¼•å·æˆ–åŒå¼•å·å¼•èµ·æ¥çš„ç¬¦å·ã€‚ä¾‹å¦‚ï¼š`hex"001122FF"`ï¼Œå­—ç¬¦ä¸²çš„å†…å®¹å¿…é¡»æ˜¯ä¸€ä¸ªåå…­è¿›åˆ¶çš„å­—ç¬¦ä¸²ï¼Œå®ƒä»¬çš„å€¼å°†ä½¿ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºã€‚åå…­è¿›åˆ¶å­—é¢å¸¸é‡è·Ÿå­—ç¬¦ä¸²å­—é¢å¸¸é‡å¾ˆç±»ä¼¼ï¼Œå…·æœ‰ç›¸åŒçš„è½¬æ¢è§„åˆ™ã€‚

- æšä¸¾ç±»å‹ï¼šæšä¸¾æ˜¯åœ¨ Solidity ä¸­åˆ›å»ºç”¨æˆ·å®šä¹‰ç±»å‹çš„ä¸€ç§æ–¹æ³•ã€‚å®ƒä»¬æ˜¯æ˜¾ç¤ºæ‰€æœ‰æ•´å‹ç›¸äº’è½¬æ¢ï¼Œä½†ä¸å…è®¸éšå¼è½¬æ¢ã€‚ä»æ•´å‹æ˜¾å¼è½¬æ¢æšä¸¾ï¼Œä¼šåœ¨è¿è¡Œæ—¶æ£€æŸ¥æ•´æ•°æ—¶å€™åœ¨æšä¸¾èŒƒå›´å†…ï¼Œå¦åˆ™ä¼šå¯¼è‡´å¼‚å¸¸ï¼ˆPanic å¼‚å¸¸ï¼‰ã€‚æšä¸¾éœ€è¦è‡³å°‘ä¸€ä¸ªæˆå‘˜ï¼Œæšä¸¾ä¸èƒ½å¤šäº 256 ä¸ªæˆå‘˜ã€‚
  ä½¿ç”¨`type(NameOfEnum).min` å’Œ `type(NameOfEnum).max`ä½ å¯ä»¥å¾—åˆ°ç»™å®šæšä¸¾çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ã€‚
  æšä¸¾è¿˜å¯ä»¥åœ¨åˆçº¦æˆ–åº“å®šä¹‰ä¹‹å¤–çš„æ–‡ä»¶çº§åˆ«ä¸Šå£°æ˜

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;

contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
    ActionChoices choice;
    ActionChoices constant defaultChoice = ActionChoices.GoStraight;

    function setGoStraight() public {
        choice = ActionChoices.GoStraight;
    }

    // ç”±äºæšä¸¾ç±»å‹ä¸å±äº |ABI| çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤å¯¹äºæ‰€æœ‰æ¥è‡ª Solidity å¤–éƒ¨çš„è°ƒç”¨ï¼Œ
    // "getChoice" çš„ç­¾åä¼šè‡ªåŠ¨è¢«æ”¹æˆ "getChoice() returns (uint8)"ã€‚

    function getChoice() public view returns (ActionChoices) {
        return choice;
    }

    function getDefaultChoice() public pure returns (uint) {
        return uint(defaultChoice);
    }

    function getLargestValue() public pure returns (ActionChoices) {
        return type(ActionChoices).max;
    }

    function getSmallestValue() public pure returns (ActionChoices) {
        return type(ActionChoices).min;
    }
}
```

- ç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹ï¼šä¸€ä¸ªç”¨æˆ·å®šä¹‰çš„å€¼ç±»å‹å…è®¸åœ¨ä¸€ä¸ªåŸºç¡€çš„å€¼ç±»å‹ä¸Šåˆ›å»ºä¸€ä¸ªé›¶æˆæœ¬çš„æŠ½è±¡ã€‚è¿™ç±»ä¼¼ä¸€ä¸ªåˆ«åï¼Œä½†æœ‰æ›´ä¸¥æ ¼çš„ç±»å‹è¦æ±‚ã€‚
  ç”¨æˆ·å®šä¹‰å€¼ç±»å‹ä½¿ç”¨`type C is V`æ¥å®šä¹‰ï¼Œå…¶ä¸­`C`æ˜¯æ–°å¼•å…¥çš„ç±»å‹çš„åç§°ï¼Œ`V`å¿…é¡»æ˜¯å†…ç½®çš„å€¼ç±»å‹ï¼ˆâ€˜åº•å±‚ç±»å‹â€™ï¼‰ã€‚å‡½æ•°`C.wrap`è¢«ç”¨æ¥ä»åº•å±‚ç±»å‹è½¬æ¢åˆ°è‡ªå®šä¹‰ç±»å‹ã€‚åŒæ ·åœ°ï¼Œå‡½æ•°`C.unwrap`ç”¨äºä»è‡ªå®šä¹‰ç±»å‹è½¬æ¢åˆ°åº•å±‚ç±»å‹ã€‚
  ç±»å‹`C`æ²¡æœ‰ä»»ä½•çš„è¿ç®—ç¬¦æˆ–ç»‘å®šæˆå‘˜ã€‚ç‰¹åˆ«æ˜¯ï¼Œå³ä½¿æ˜¯æ“ä½œç¬¦`==`ä¹Ÿæ²¡æœ‰å®šä¹‰ã€‚ä¹Ÿä¸å…è®¸ä¸å…¶ä»–ç±»å‹è¿›è¡Œæ˜¾ç¤ºæˆ–éšå¼è½¬æ¢ã€‚
  è‡ªå®šä¹‰ç±»å‹çš„å€¼çš„æ•°æ®è¡¨ç¤ºåˆ™ç»§æ‰¿è‡ªåº•å±‚ç±»å‹ï¼Œå¹¶ä¸” ABI ä¸­ä¹Ÿä½¿ç”¨åº•å±‚ç±»å‹ã€‚
  ä¸‹é¢çš„ä¾‹å­è¯´æ˜äº†ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹`UFixed256x18`ï¼Œä»£è¡¨äº†ä¸€ä¸ªæœ‰ 18 ä½å°æ•°çš„åè¿›åˆ¶å®šç‚¹ç±»å‹ï¼Œå¹¶æœ‰ä¸€ä¸ªåº“æ¥å¯¹è¯¥ç±»å‹è¿›è¡Œç®—æœ¯æ“ä½œã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;

// Represent a 18 decimal, 256 bit wide fixed point type using a user defined value type.
type UFixed256x18 is uint256;

/// A minimal library to do fixed point operations on UFixed256x18.
library FixedMath {
    uint constant multiplier = 10**18;

    /// Adds two UFixed256x18 numbers. Reverts on overflow, relying on checked
    /// arithmetic on uint256.
    function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));
    }
    /// Multiplies UFixed256x18 and uint256. Reverts on overflow, relying on checked
    /// arithmetic on uint256.
    function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);
    }
    /// Take the floor of a UFixed256x18 number.
    /// @return the largest integer that does not exceed `a`.
    function floor(UFixed256x18 a) internal pure returns (uint256) {
        return UFixed256x18.unwrap(a) / multiplier;
    }
    /// Turns a uint256 into a UFixed256x18 of the same value.
    /// Reverts if the integer is too large.
    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {
        return UFixed256x18.wrap(a * multiplier);
    }
}

```

- å‡½æ•°ç±»å‹ï¼šå‡½æ•°ç±»å‹æ˜¯ä¸€ç§è¡¨ç¤ºå‡½æ•°çš„ç±»å‹ã€‚å¯ä»¥å°†ä¸€ä¸ªå‡½æ•°èµ‹å€¼ç»™å¦ä¸€ä¸ªå‡½æ•°ç±»å‹çš„å˜é‡ï¼Œä¹Ÿå¯ä»¥å°†ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œè¿˜èƒ½åœ¨å‡½æ•°è°ƒç”¨ä¸­è¿”å›å‡½æ•°ç±»å‹ã€‚å‡½æ•°ç±»å‹æœ‰ä¸¤ç±»ï¼š
  - å†…éƒ¨ï¼ˆinternalï¼‰å‡½æ•°ç±»å‹ï¼šå†…éƒ¨å‡½æ•°ç±»å‹åªèƒ½åœ¨å½“å‰åˆçº¦å†…è¢«è°ƒç”¨ã€‚
  - å¤–éƒ¨ï¼ˆexternalï¼‰å‡½æ•°ç±»å‹ï¼šå¤–éƒ¨å‡½æ•°æ˜¯ç”±ä¸€ä¸ªåœ°å€å’Œä¸€ä¸ªå‡½æ•°ç­¾åç»„æˆï¼Œå¯ä»¥é€šè¿‡å¤–éƒ¨å‡½æ•°è°ƒç”¨ä¼ é€’æˆ–è¿”å›ã€‚
    å‡½æ•°ç±»å‹è¡¨ç¤ºæˆå¦‚ä¸‹å½¢å¼ï¼š
    `function (<parameter types>) {internal|external} [pure|constant|view|payable[returns (<return types>)]`
    ä¸å‚æ•°ç›¸åï¼Œè¿”å›ç±»å‹ä¸èƒ½ä¸ºç©ºâ€”â€”å¦‚æœå‡½æ•°ç±»å‹ä¸éœ€è¦è¿”å›å€¼ï¼Œåˆ™éœ€è¦åˆ é™¤æ•´ä¸ª`returns (<return types>)`éƒ¨åˆ†
    å‡½æ•°ç±»å‹é»˜è®¤æ˜¯å†…éƒ¨å‡½æ•°ï¼Œå› æ­¤ä¸éœ€è¦å£°æ˜`internal`å…³é”®å­—
    **æ³¨æ„ï¼š** è¿™ä»…é€‚ç”¨äºå‡½æ•°ç±»å‹ï¼Œåˆçº¦ä¸­å®šä¹‰çš„å‡½æ•°æ˜ç¡®æŒ‡å®šå¯è§æ€§ï¼Œå®ƒä»¬æ˜¯æ²¡æœ‰é»˜è®¤å€¼çš„ã€‚
    ç±»å‹è½¬æ¢ï¼šå‡½æ•°ç±»å‹`A`å¯ä»¥éšå¼è½¬æ¢ä¸ºå‡½æ•°ç±»å‹`B`
    å½“ä¸”ä»…å½“ï¼š - å®ƒä»¬çš„å‚æ•°ç±»å‹ç›¸åŒ - å®ƒä»¬çš„è¿”å›å€¼ç±»å‹ç›¸åŒ - å®ƒä»¬çš„å†…éƒ¨/å¤–éƒ¨å±æ€§ç›¸åŒ - å¹¶ä¸”`A`çš„çŠ¶æ€å¯å˜æ€§æ¯”`B`çš„çŠ¶æ€å¯å˜æ€§æ›´å…·é™åˆ¶æ€§ï¼Œæ¯”å¦‚ï¼š - `pure`å‡½æ•°å¯ä»¥è½¬æ¢ä¸º`view`å’Œ`non-payable`å‡½æ•° - `view`å‡½æ•°å¯ä»¥è½¬æ¢ä¸º`non-payable`å‡½æ•° - `payable`å‡½æ•°å¯ä»¥è½¬æ¢ä¸º`non-payable`å‡½æ•°
    å…³äº `payable` å’Œ `non-payable` çš„è§„åˆ™å¯èƒ½æœ‰ç‚¹ä»¤äººå›°æƒ‘ï¼Œä½†å®è´¨ä¸Šï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°æ˜¯ `payable` ï¼Œè¿™æ„å‘³ç€å®ƒ ä¹Ÿæ¥å—é›¶ä»¥å¤ªçš„æ”¯ä»˜ï¼Œå› æ­¤å®ƒä¹Ÿæ˜¯ `non-payable` ã€‚ å¦ä¸€æ–¹é¢ï¼Œ`non-payable` å‡½æ•°å°†æ‹’ç»å‘é€ç»™å®ƒçš„ ä»¥å¤ªå¸ Ether ï¼Œ æ‰€ä»¥ `non-payable` å‡½æ•°ä¸èƒ½è½¬æ¢ä¸º `payable` å‡½æ•°ã€‚
    å¦‚æœå¤–éƒ¨å‡½æ•°ç±»å‹åœ¨ Solidity çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä»¥å¤–çš„åœ°æ–¹ä½¿ç”¨ï¼Œå®ƒä»¬ä¼šè¢«è§†ä¸º`function`ç±»å‹ã€‚è¯¥ç±»å‹å°†å‡½æ•°åœ°å€ç´§è·Ÿå…¶å‡½æ•°æ ‡è¯†ä¸€èµ·ç¼–ç ä¸ºä¸€ä¸ª`betys24`ç±»å‹ã€‚
    **è¯·æ³¨æ„**ï¼Œå½“å‰åˆçº¦çš„ public å‡½æ•°æ—¢å¯ä»¥è¢«å½“åšå†…éƒ¨å‡½æ•°ä¹Ÿå¯ä»¥è¢«å½“åšå¤–éƒ¨å‡½æ•°ä½¿ç”¨ã€‚å¦‚æœæƒ³å°†ä¸€ä¸ªå‡½æ•°å½“åšå†…éƒ¨å‡½æ•°ä½¿ç”¨ï¼Œå°±ç”¨`f`è°ƒç”¨ï¼Œå¦‚æœæƒ³å°†å…¶å½“åšå¤–éƒ¨å‡½æ•°ï¼Œä½¿ç”¨`this.f`ã€‚
    ä¸€ä¸ªå†…éƒ¨å‡½æ•°å¯ä»¥è¢«åˆ†é…ç»™ä¸€ä¸ªå†…éƒ¨å‡½æ•°ç±»å‹çš„å˜é‡ï¼Œæ— è®ºå®šä¹‰åœ¨å“ªé‡Œï¼ŒåŒ…æ‹¬åˆçº¦å’Œåº“çš„ç§æœ‰ï¼Œå†…éƒ¨å’Œ public å‡½æ•°ï¼Œä»¥åŠè‡ªç”±å‡½æ•°ã€‚å¦ä¸€æ–¹é¢ï¼Œå¤–éƒ¨å‡½æ•°ç±»å‹åªä¸ public å’Œå¤–éƒ¨åˆçº¦å‡½æ•°å…¼å®¹ã€‚åº“æ˜¯ä¸å¯ä»¥çš„ï¼Œå› ä¸ºåº“ä½¿ç”¨`delegatecall`ï¼Œå¹¶ä¸”å®ƒä»¬çš„å‡½æ•°é€‰æ‹©å™¨æœ‰ä¸åŒçš„ ABI è½¬æ¢ã€‚æ¥å£å£°æ˜çš„å‡½æ•°æ²¡æœ‰å®šä¹‰ï¼Œæ‰€ä»¥æŒ‡å‘å®ƒä»¬ä¹Ÿæ²¡æœ‰æ„ä¹‰ã€‚
    æˆå‘˜ï¼š
    publicï¼ˆæˆ– externalï¼‰å‡½æ•°éƒ½æœ‰ä¸‹é¢çš„æˆå‘˜
- `address`å±æ€§ï¼šè¿”å›å‡½æ•°çš„åˆçº¦åœ°å€
- `selector`å±æ€§ï¼šè¿”å› ABI å‡½æ•°çš„é€‰æ‹©å™¨

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.4  <0.9.0;
//ä½¿ç”¨æˆå‘˜çš„ä¾‹å­
contract Example {
  function f() public payable returns (bytes4) {
    assert(this.f.address == address(this));
    return this.f.selector;
  }
  function g() public {
    this.f{gas: 10, value: 800}();
  }
}

//ä½¿ç”¨å†…éƒ¨å‡½æ•°ç±»å‹çš„ä¾‹å­
library ArrayUtils {
  // å†…éƒ¨å‡½æ•°å¯ä»¥åœ¨å†…éƒ¨åº“å‡½æ•°ä¸­ä½¿ç”¨ï¼Œ
  // å› ä¸ºå®ƒä»¬ä¼šæˆä¸ºåŒä¸€ä»£ç ä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†
  function map(uint[] memory self, function (uint) pure returns (uint) f)
    internal
    pure
    returns (uint[] memory r)
  {
    r = new uint[](self.length);
    for (uint i = 0; i < self.length; i++) {
      r[i] = f(self[i]);
    }
  }
  function reduce(
    uint[] memory self,
    function (uint, uint) pure returns (uint) f
  )
    internal
    pure
    returns (uint r)
  {
    r = self[0];
    for (uint i = 1; i < self.length; i++) {
      r = f(r, self[i]);
    }
  }
  function range(uint length) internal pure returns (uint[] memory r) {
    r = new uint[](length);
    for (uint i = 0; i < r.length; i++) {
      r[i] = i;
    }
  }
}

contract Pyramid {
  using ArrayUtils for *;
  function pyramid(uint l) public pure returns (uint) {
    return ArrayUtils.range(l).map(square).reduce(sum);
  }
  function square(uint x) internal pure returns (uint) {
    return x * x;
  }
  function sum(uint x, uint y) internal pure returns (uint) {
    return x + y;
  }
}

//ä½¿ç”¨å¤–éƒ¨å‡½æ•°ç±»å‹çš„ä¾‹å­
contract Oracle {
  struct Request {
    bytes data;
    function(uint) external callback;
  }
  Request[] private requests;
  event NewRequest(uint);
  function query(bytes memory data, function(uint) external callback) public {
    requests.push(Request(data, callback));
    emit NewRequest(requests.length - 1);
  }
  function reply(uint requestID, uint response) public {
    // è¿™é‡Œæ£€æŸ¥å›å¤æ¥è‡ªå¯ä¿¡æ¥æº
    requests[requestID].callback(response);
  }
}

contract OracleUser {
  Oracle constant private ORACLE_CONST = Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract
  uint private exchangeRate;
  function buySomething() public {
    ORACLE_CONST.query("USD", this.oracleResponse);
  }
  function oracleResponse(uint response) public {
    require(
        msg.sender == address(ORACLE_CONST),
        "Only oracle can call this."
    );
    exchangeRate = response;
  }
}
```

### å¼•ç”¨ç±»å‹

å¼•ç”¨ç±»å‹å¯ä»¥é€šè¿‡å¤šä¸ªä¸åŒçš„åç§°ä¿®æ”¹å®ƒçš„å€¼ï¼Œè€Œå€¼çš„ç±»å‹çš„å˜é‡ï¼Œæ¯æ¬¡éƒ½æœ‰ç‹¬ç«‹çš„å‰¯æœ¬ã€‚å› æ­¤ï¼Œå¿…é¡»æ¯”å€¼ç±»å‹æ›´è°¨æ…çš„å¤„ç†å¼•ç”¨ç±»å‹ã€‚ç›®å‰ï¼Œå¼•ç”¨ç±»å‹åŒ…æ‹¬ç»“æ„ï¼Œæ•°ç»„å’Œæ˜ å°„ï¼Œå¦‚æœä½¿ç”¨å¼•ç”¨ç±»å‹ï¼Œåˆ™å¿…é¡»æ˜ç¡®æŒ‡æ˜æ•°æ®å‚¨å­˜å“ªç§ç±»å‹çš„ä½ç½®ï¼ˆç©ºé—´ï¼‰é‡Œï¼š

- å†…å­˜ï¼ˆmemoryï¼‰å³æ•°æ®åœ¨å†…å­˜ä¸­ï¼Œå› æ­¤æ•°æ®ä»…åœ¨å…¶ç”Ÿå‘½å‘¨æœŸå†…ï¼ˆå‡½æ•°è°ƒç”¨æœŸé—´ï¼‰æœ‰æ•ˆã€‚ä¸èƒ½ç”¨äºå¤–éƒ¨è°ƒç”¨ã€‚
- å‚¨å­˜ï¼ˆstorageï¼‰çŠ¶æ€å˜é‡ä¿å­˜çš„ä½ç½®ï¼Œåªè¦åˆçº¦å­˜åœ¨å°±ä¸€ç›´å‚¨å­˜ã€‚
- è°ƒç”¨æ•°æ®ï¼ˆcalldataï¼‰ç”¨æ¥ä¿å­˜å‡½æ•°å‚æ•°çš„ç‰¹æ®Šæ•°æ®ä½ç½®ï¼Œæ˜¯ä¸€ä¸ªåªè¯»ä½ç½®ã€‚

æ›´æ”¹æ•°æ®ä½ç½®æˆ–ç±»å‹è½¬æ¢å°†å§‹ç»ˆäº§ç”Ÿè‡ªåŠ¨è¿›è¡Œä¸€ä»½æ‹·è´ï¼Œè€Œåœ¨åŒä¸€æ•°æ®ä½ç½®å†…ï¼ˆå¯¹äºå‚¨å­˜ storage æ¥è¯´ï¼‰çš„å¤åˆ¶ä»…åœ¨æŸäº›æƒ…å†µä¸‹è¿›è¡Œæ‹·è´ã€‚

#### æ•°æ®ä½ç½®

æ‰€æœ‰çš„å¼•ç”¨ç±»å‹ï¼Œå¦‚æ•°ç»„å’Œç»“æ„ä½“ç±»å‹ï¼Œéƒ½æœ‰ä¸€ä¸ªé¢å¤–çš„æ³¨è§£`æ•°æ®ä½ç½®`ï¼Œæ¥è¯´æ˜æ•°æ®å‚¨å­˜ä½ç½®ã€‚
æœ‰ä¸‰ç§ä½ç½®ï¼šå†…å­˜ï¼ˆmemoryï¼‰ã€å‚¨å­˜ï¼ˆstorageï¼‰ã€ä»¥åŠè°ƒç”¨æ•°æ®ï¼ˆcalldataï¼‰ã€‚è°ƒç”¨æ•°æ®ï¼ˆcalldataï¼‰æ˜¯ä¸å¯ä¿®æ”¹çš„ã€éæŒä¹…çš„å‡½æ•°å‚æ•°å‚¨å­˜åŒºåŸŸï¼Œæ•ˆæœå¤§å¤šç±»ä¼¼å†…å­˜ï¼ˆmemoryï¼‰ã€‚ä¸»è¦ç”¨äºå¤–éƒ¨å‡½æ•°çš„å‚æ•°ï¼Œä½†ä¹Ÿå¯ç”¨äºå…¶ä»–å˜é‡ã€‚
**æ•°æ®ä½ç½®ä¸èµ‹å€¼è¡Œä¸º**ï¼šæ•°æ®ä½ç½®ä¸ä»…ä»…è¡¨ç¤ºæ•°æ®å¦‚ä½•ä¿å­˜ï¼Œå®ƒåŒæ ·å½±å“è¿™èµ‹å€¼è¡Œä¸ºï¼š

- åœ¨å‚¨å­˜ï¼ˆstorageï¼‰å’Œå†…å­˜ï¼ˆmemoryï¼‰ä¹‹é—´ä¸¤ä¸¤èµ‹å€¼ï¼ˆæˆ–è€…ä»è°ƒç”¨æ•°æ®ï¼ˆcalldataï¼‰èµ‹å€¼ï¼‰ï¼Œéƒ½ä¼šåˆ›å»ºä¸€ä»½ç‹¬ç«‹çš„æ‹·è´ã€‚
- ä»å†…å­˜ï¼ˆmemoryï¼‰åˆ°å†…å­˜ï¼ˆmemoryï¼‰çš„èµ‹å€¼åªåˆ›å»ºå¼•ç”¨ï¼Œè¿™æ„å‘³ç€æ›´æ”¹å†…å­˜å˜é‡ï¼Œå…¶ä»–å¼•ç”¨ç›¸åŒæ•°æ®çš„æ‰€æœ‰å…¶ä»–å†…å­˜å˜é‡çš„å€¼ä¹Ÿä¼šè·Ÿç€æ”¹å˜ã€‚
- ä»å‚¨å­˜ï¼ˆstorageï¼‰åˆ°æœ¬åœ°å‚¨å­˜ï¼ˆstorageï¼‰å˜é‡çš„èµ‹å€¼ä¹Ÿåªåˆ†é…ä¸€ä¸ªå¼•ç”¨
- å…¶ä»–çš„åƒå‚¨å­˜ï¼ˆstorageï¼‰çš„èµ‹å€¼ï¼Œæ€»æ˜¯è¿›è¡Œæ‹·è´ã€‚è¿™ç§æƒ…å†µçš„ç¤ºä¾‹å¦‚ä¸‹ï¼šå¯¹çŠ¶æ€å˜é‡æˆ–å‚¨å­˜ï¼ˆstorageï¼‰çš„ç»“æ„ä½“ç±»å‹çš„å±€éƒ¨å˜é‡æˆå‘˜èµ‹å€¼ï¼Œå³ä½¿å±€éƒ¨å˜é‡æœ¬èº«æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œä¹Ÿä¼šè¿›è¡Œä¸€ä»½æ‹·è´ã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.5.0 <0.9.0;

contract Tiny {
    uint[] x; // x çš„æ•°æ®å­˜å‚¨ä½ç½®æ˜¯ storageï¼Œã€€ä½ç½®å¯ä»¥å¿½ç•¥

    // memoryArray çš„æ•°æ®å­˜å‚¨ä½ç½®æ˜¯ memory
    function f(uint[] memory memoryArray) public {
        x = memoryArray; // å°†æ•´ä¸ªæ•°ç»„æ‹·è´åˆ° storage ä¸­ï¼Œå¯è¡Œ
        uint[] storage y = x;  // åˆ†é…ä¸€ä¸ªæŒ‡é’ˆï¼ˆå…¶ä¸­ y çš„æ•°æ®å­˜å‚¨ä½ç½®æ˜¯ storageï¼‰ï¼Œå¯è¡Œ
        y[7]; // è¿”å›ç¬¬ 8 ä¸ªå…ƒç´ ï¼Œå¯è¡Œ
        y.pop(); // é€šè¿‡ y ä¿®æ”¹ xï¼Œå¯è¡Œ
        delete x; // æ¸…é™¤æ•°ç»„ï¼ŒåŒæ—¶ä¿®æ”¹ yï¼Œå¯è¡Œ

        // ä¸‹é¢çš„å°±ä¸å¯è¡Œäº†ï¼›éœ€è¦åœ¨ storage ä¸­åˆ›å»ºæ–°çš„æœªå‘½åçš„ä¸´æ—¶æ•°ç»„ï¼Œ
        // ä½† storage æ˜¯â€œé™æ€â€åˆ†é…çš„ï¼š
        // y = memoryArray;
        // ä¸‹é¢è¿™ä¸€è¡Œä¹Ÿä¸å¯è¡Œï¼Œå› ä¸ºè¿™ä¼šâ€œé‡ç½®â€æŒ‡é’ˆï¼Œ
        // ä½†å¹¶æ²¡æœ‰å¯ä»¥è®©å®ƒæŒ‡å‘çš„åˆé€‚çš„å­˜å‚¨ä½ç½®ã€‚
        // delete y;

        g(x); // è°ƒç”¨ g å‡½æ•°ï¼ŒåŒæ—¶ç§»äº¤å¯¹ x çš„å¼•ç”¨
        h(x); // è°ƒç”¨ h å‡½æ•°ï¼ŒåŒæ—¶åœ¨ memory ä¸­åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ä¸´æ—¶æ‹·è´
    }

    function g(uint[] storage ) internal pure {}
    function h(uint[] memory) public pure {}
}
```

#### æ•°ç»„

å¯ä»¥åœ¨å£°æ˜æ—¶æŒ‡å®šé•¿åº¦ï¼Œä¹Ÿå¯ä»¥åŠ¨æ€è°ƒæ•´å¤§å°ï¼ˆé•¿åº¦ï¼‰ã€‚

- ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸º`T`ï¼Œå›ºå®šé•¿åº¦ä¸º`K`çš„æ•°ç»„å¯ä»¥å£°æ˜ä¸º`T[K]`ï¼Œè€ŒåŠ¨æ€æ•°ç»„å£°æ˜ä¸º`T[]`ã€‚æ¯”å¦‚ï¼šä¸€ä¸ªé•¿åº¦ä¸º 5ï¼Œå…ƒç´ ç±»å‹ä¸º uint çš„åŠ¨æ€æ•°ç»„çš„æ•°ç»„ï¼ˆäºŒç»´æ•°ç»„ï¼‰ï¼Œåº”å£°æ˜ä¸º`uint[][5]`ï¼Œæ³¨æ„è¿™é‡Œè·Ÿå…¶ä»–è¯­è¨€æ¯”ï¼Œæ•°ç»„é•¿åº¦çš„å£°æ˜ä½ç½®æ˜¯åçš„
- åœ¨ Solidity ä¸­ï¼Œ`X[3]`æ€»æ˜¯ä¸€ä¸ªåŒ…å«ä¸‰ä¸ª`X`ç±»å‹å…ƒç´ çš„æ•°ç»„ï¼Œå³ä½¿`X`æœ¬èº«æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè¿™å’Œå…¶ä»–è¯­è¨€ä¹Ÿæœ‰æ‰€ä¸åŒã€‚
- æ•°ç»„çš„ä¸‹æ ‡æ˜¯ä» 0 å¼€å§‹çš„ï¼Œä¸”è®¿é—®æ•°ç»„æ—¶çš„ä¸‹æ ‡é¡ºåºä¸å£°æ˜ç›¸åã€‚æ¯”å¦‚ï¼šå¦‚æœæœ‰ä¸€ä¸ªå˜é‡ä¸º`uint[][5] memory x`ï¼Œè¦è®¿é—®ç¬¬ä¸‰ä¸ªåŠ¨æ€æ•°ç»„çš„ç¬¬ 7 ä¸ªå…ƒç´ ï¼Œä½¿ç”¨`x[2][6]`ï¼Œè¦è®¿é—®ç¬¬ä¸‰ä¸ªåŠ¨æ€æ•°ç»„ä½¿ç”¨`x[2]`ã€‚åŒæ ·ï¼Œå¦‚æœæœ‰ä¸€ä¸ª`T`ç±»å‹çš„æ•°ç»„`T[5] a`ï¼Œ`T`ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œé‚£ä¹ˆ`a[2]`æ€»ä¼šæ˜¯`T`ç±»å‹ã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼ŒåŒ…æ‹¬æ˜ å°„æˆ–ç»“æ„ä½“ã€‚å¯¹ç±»å‹çš„é™åˆ¶æ˜¯æ˜ å°„åªèƒ½å‚¨å­˜åœ¨å‚¨å­˜ï¼ˆstorageï¼‰ä¸­ï¼Œå¹¶ä¸”å…¬å¼€è®¿é—®å‡½æ•°çš„å‚æ•°éœ€è¦æ˜¯ ABI ç±»å‹ã€‚
- çŠ¶æ€å˜é‡æ ‡è®°`public`çš„æ•°ç»„ï¼ŒSolidity åˆ›å»ºä¸€ä¸ª getter å‡½æ•°ã€‚å°æ ‡æ•°å­—ç´¢å¼•å°±æ˜¯ getter å‡½æ•°çš„å‚æ•°ã€‚
- è®¿é—®è¶…å‡ºæ•°ç»„é•¿åº¦çš„å…ƒç´ ä¼šå¯¼è‡´å¼‚å¸¸ï¼ˆassert ç±»å‹å¼‚å¸¸ï¼‰ã€‚å¯ä»¥ä½¿ç”¨`push`æ–¹æ³•åœ¨æœ«å°¾è¿½åŠ ä¸€ä¸ªæ–°å…ƒç´ ï¼Œå…¶ä¸­`push`æ–¹æ³•è¿½åŠ ä¸€ä¸ªé›¶åˆå§‹åŒ–çš„å…ƒç´ å¹¶è¿”å›å¯¹å®ƒçš„å¼•ç”¨ã€‚

##### `bytes`å’Œ`string`ä¹Ÿæ˜¯æ•°ç»„

`bytes`å’Œ`string`ç±»å‹çš„å˜é‡æ˜¯ç‰¹æ®Šç±»å‹çš„æ•°ç»„ã€‚`bytes`ç±»ä¼¼äº`bytes1[]`ï¼Œä½†å®ƒåœ¨è°ƒç”¨æ•°æ®ï¼ˆcalldataï¼‰å’Œå†…å­˜ï¼ˆmemoryï¼‰ä¸­ä¼šè¢«â€œç´§æ‰“åŒ…â€ï¼ˆå°†å…ƒç´ è¿ç»­çš„å­˜åœ¨ä¸€èµ·ï¼Œä¸ä¼šæŒ‰æ¯ 32 å­—èŠ‚ä¸€å•ä½çš„æ–¹å¼æ¥å­˜æ”¾ï¼‰ã€‚`string`å’Œ`bytes`ç›¸åŒï¼Œä½†ä¸å…è®¸ç”¨é•¿åº¦æˆ–ç´¢å¼•æ¥è®¿é—®ã€‚
Solidity æ²¡æœ‰å­—ç¬¦ä¸²æ“ä½œå‡½æ•°ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼Œæˆ‘ä»¬å¯ä»¥æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²é€šè¿‡è®¡ç®—å®ƒä»¬çš„ keccak256-hashï¼Œå¯ä½¿ç”¨`keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2)))` å’Œä½¿ç”¨`string.concat(s1,s2)`æ¥æ‹¼æ¥å­—ç¬¦ä¸²ã€‚
æˆ‘ä»¬æ›´å¤šæ—¶å€™åº”è¯¥ä½¿ç”¨`bytes`è€Œä¸æ˜¯`bytes1[]`ï¼Œå› ä¸º Gas è´¹ç”¨æ›´ä½ï¼Œåœ¨å†…å­˜ï¼ˆmemoryï¼‰ä¸­ä½¿ç”¨`bytes1[]`æ—¶ï¼Œä¼šåœ¨å…ƒç´ ä¹‹é—´æ·»åŠ  31 ä¸ªå¡«å……å­—èŠ‚ã€‚è€Œåœ¨å‚¨å­˜ï¼ˆstorageï¼‰ä¸­ï¼Œç”±äºç´§å¯†åŒ…è£…ï¼Œè¿™æ²¡æœ‰å¡«å……å­—èŠ‚ã€‚ä½œä¸ºä¸€ä¸ªåŸºæœ¬è§„åˆ™ï¼Œå¯¹ä»»æ„é•¿åº¦çš„åŸå§‹å­—èŠ‚æ•°æ®ä½¿ç”¨`bytes`ï¼Œå¯¹ä»»æ„é•¿åº¦å­—ç¬¦ä¸²æ•°æ®ä½¿ç”¨`string`ã€‚
å¦‚æœä½¿ç”¨ä¸€ä¸ªé•¿åº¦é™åˆ¶çš„å­—èŠ‚æ•°ç»„ï¼Œåº”è¯¥ä½¿ç”¨ä¸€ä¸ª`bytes1`åˆ°`bytes32`çš„å…·ä½“ç±»å‹ï¼Œå› ä¸ºå®ƒä»¬ä¾¿å®œçš„å¤šã€‚

###### å‡½æ•°`bytes.concat`å’Œ`string.concat`

å¯ä»¥ä½¿ç”¨`string.concat`è¿æ¥ä»»æ„æ•°é‡çš„`string`å­—ç¬¦ä¸²ã€‚è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª`string memory`ï¼ŒåŒ…å«æ‰€æœ‰å‚æ•°çš„å†…å®¹ï¼Œæ— å¡«å……æ–¹å¼æ‹¼æ¥åœ¨ä¸€èµ·ã€‚å¦‚æœä½ æƒ³ä½¿ç”¨ä¸èƒ½éšå¼è½¬æ¢ä¸º`string`çš„å…¶ä»–ç±»å‹ä½œä¸ºå‚æ•°ï¼Œä½ éœ€è¦å…ˆæŠŠå®ƒä»¬è½¬æ¢ä¸º`string`ã€‚
åŒæ ·ï¼Œ`bytes.concat`å‡½æ•°å¯ä»¥è¿æ¥ä»»æ„æ•°é‡çš„`bytes`æˆ–`bytes1`â€¦â€¦`bytes32`å€¼ã€‚è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª`betys memory`ï¼ŒåŒ…å«æ‰€æœ‰å‚æ•°çš„å†…å®¹ï¼Œæ— å¡«å……æ–¹å¼æ‹¼æ¥åœ¨ä¸€èµ·ã€‚å¦‚æœä½ æƒ³ä½¿ç”¨å­—ç¬¦ä¸²å‚æ•°æˆ–è€…å…¶ä»–ä¸èƒ½éšå¼è½¬æ¢ä¸º`bytes`çš„ç±»å‹ï¼Œä½ éœ€è¦å…ˆå°†å®ƒä»¬è½¬æ¢ä¸º`bytes`æˆ–`bytes1`â€¦â€¦`bytes32`ã€‚
å¦‚æœä½ è°ƒç”¨ä¸ä½¿ç”¨å‚æ•°è°ƒç”¨`string.concat`æˆ–`bytes.concat`å°†è¿”å›ç©ºæ•°ç»„ã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.12;

contract C {
    string s = "Storage";
    function f(bytes calldata bc, string memory sm, bytes16 b) public view {
        string memory concatString = string.concat(s, string(bc), "Literal", sm);
        assert((bytes(s).length + bc.length + 7 + bytes(sm).length) == bytes(concatString).length);

        bytes memory concatBytes = bytes.concat(bytes(s), bc, bc[:2], "Literal", bytes(sm), b);
        assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) == concatBytes.length);
    }
}
```

###### åˆ›å»ºå†…å­˜æ•°ç»„

å¯ä½¿ç”¨`new`å…³é”®å­—åœ¨å†…å­˜ï¼ˆmemoryï¼‰ä¸­åŸºäºè¿è¡Œæ—¶åˆ›å»ºåŠ¨æ€é•¿åº¦æ•°ç»„ã€‚ä¸å‚¨å­˜ï¼ˆstorageï¼‰æ•°ç»„ç›¸åçš„æ˜¯ï¼Œä½ ä¸èƒ½é€šè¿‡`push`æ”¹å˜å†…å­˜æ•°ç»„çš„å¤§å°
å¿…é¡»æå‰è®¡ç®—æ‰€éœ€çš„å¤§å°æˆ–è€…åˆ›å»ºä¸€ä¸ªæ–°çš„å†…å­˜æ•°ç»„å¹¶å¤åˆ¶æ¯ä¸ªå…ƒç´ ã€‚
åœ¨ Solidity ä¸­çš„æ‰€æœ‰å˜é‡ï¼Œæ–°åˆ†é…çš„æ•°ç»„å…ƒç´ æ€»æ˜¯ä»¥é»˜è®¤å€¼åˆå§‹åŒ–ã€‚

```sol
pragma solidity >=0.4.16 <0.9.0;

contract TX {
    function f(uint len) public pure {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);

        assert(a.length == 7);
        assert(b.length == len);

        a[6] = 8;
    }
}
```

###### æ•°ç»„å¸¸é‡

æ•°ç»„å¸¸é‡ï¼ˆå­—é¢é‡ï¼‰æ˜¯åœ¨æ–¹æ‹¬å·ï¼ˆ`[...]`ï¼‰åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªé€—å·åˆ†éš”çš„è¡¨è¾¾å¼ã€‚ä¾‹å¦‚ï¼š`[1,a,f(3)]`ã€‚
æ•°ç»„å¸¸é‡çš„ç±»å‹é€šè¿‡ä»¥ä¸‹æ–¹å¼ç¡®å®šï¼š

- å®ƒæ€»æ˜¯ä¸€ä¸ªé™æ€å¤§å°çš„å†…å­˜æ•°ç»„ï¼Œå…¶é•¿åº¦ä¸ºè¡¨è¾¾å¼çš„æ•°é‡ã€‚
- æ•°ç»„çš„åŸºæœ¬ç±»å‹æ˜¯åˆ—è¡¨ä¸Šçš„ç¬¬ä¸€ä¸ªè¡¨è¾¾å¼ç±»å‹ï¼Œä»¥ä¾¿æ‰€æœ‰å…¶ä»–è¡¨è¾¾å¼å¯ä»¥éšå¼çš„è½¬æ¢ä¸ºå®ƒã€‚å¦‚æœä¸å¯ä»¥è½¬æ¢ï¼Œå°†å‡ºç°é”™è¯¯ã€‚
- æ‰€æœ‰å…ƒç´ éƒ½å¯ä»¥è½¬æ¢ä¸ºåŸºæœ¬ç±»å‹ä¹Ÿæ˜¯ä¸å¤Ÿçš„ã€‚å…¶ä¸­ä¸€ä¸ªå…ƒç´ å¿…é¡»æ˜¯è¿™ç§ç±»å‹ã€‚
  åœ¨ä¸‹é¢ä¾‹å­ä¸­ï¼Œ`[1,2,3]`çš„ç±»å‹æ˜¯`uint8[] memory`ã€‚å› ä¸ºæ¯ä¸ªå¸¸é‡çš„ç±»å‹éƒ½æ˜¯`uint8`ï¼Œå¦‚æœä½ å¸Œæœ›ç»“æœæ˜¯`uint[3] memory`ç±»å‹ï¼Œä½ éœ€è¦å°†ç¬¬ä¸€ä¸ªå…ƒç´ è½¬æ¢ä¸º`uint`ã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract LBC {
    function f() public pure {
        g([uint(1), 2, 3]);
    }
    function g(uint[3] memory) public pure {
        // ...
    }
}
```

æ•°ç»„å¸¸é‡`[1,-1]`æ˜¯æ— æ•ˆçš„ï¼Œå› ä¸ºç¬¬ä¸€ä¸ªè¡¨è¾¾å¼ç±»å‹æ˜¯`uint8`è€Œç¬¬äºŒä¸ªè¡¨è¾¾å¼ç±»å‹æ˜¯`int8`ï¼Œå®ƒä»¬ä¸å¯ä»¥éšå¼ç›¸äº’è½¬æ¢ã€‚ä¸ºäº†ç¡®ä¿å¯ä»¥è¿è¡Œï¼Œä½ å¯ä»¥ä½¿ç”¨ä¾‹å¦‚ï¼š`[int(1),-1]`è¿›è¡Œæ˜¾å¼è½¬æ¢ã€‚

ç”±äºä¸åŒç±»å‹çš„å›ºå®šå¤§å°çš„å†…å­˜æ•°ç»„ä¸èƒ½ç›¸äº’è½¬æ¢ï¼ˆå°½ç®¡åŸºç¡€ç±»å‹å¯ä»¥ï¼‰ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨äºŒç»´æ•°ç»„å¸¸é‡ï¼Œä½ å¿…é¡»æ˜¾å¼çš„æŒ‡å®šä¸€ä¸ªåŸºç¡€ç±»å‹ï¼š

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

contract C {
    function f() public pure returns (uint24[2][4] memory) {
        uint24[2][4] memory x = [[uint24(0x1), 1], [0xffffff, 2], [uint24(0xff), 3], [uint24(0xffff), 4]];
        // ä¸‹é¢ä»£ç æ— æ³•å·¥ä½œï¼Œå› ä¸ºæ²¡æœ‰åŒ¹é…å†…éƒ¨ç±»å‹
        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];
        return x;
    }
}
```

ç›®å‰éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå®šé•¿çš„å†…å­˜æ•°ç»„ä¸èƒ½èµ‹å€¼ç»™å˜é•¿çš„å†…å­˜æ•°ç»„ï¼Œä¸‹é¢çš„ä¾‹å­æ˜¯æ— æ³•è¿è¡Œçš„ï¼š

```sol
pragma solidity  >=0.4.0 <0.9.0;

// è¿™æ®µä»£ç å¹¶ä¸èƒ½ç¼–è¯‘ã€‚
contract LBC {
    function f() public {
        // è¿™ä¸€è¡Œå¼•å‘äº†ä¸€ä¸ªç±»å‹é”™è¯¯ï¼Œå› ä¸º unint[3] memory
        // ä¸èƒ½è½¬æ¢æˆ uint[] memoryã€‚
        uint[] x = [uint(1), 3, 4];
    }
}
```

å¦‚æœè¦åˆå§‹åŒ–åŠ¨æ€é•¿åº¦çš„æ•°ç»„ï¼Œåˆ™å¿…é¡»æ˜¾å¼ç»™å„ä¸ªå…ƒç´ èµ‹å€¼ï¼š

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract C {
    function f() public pure {
        uint[] memory x = new uint[](3);
        x[0] = 1;
        x[1] = 3;
        x[2] = 4;
    }
}
```

###### æ•°ç»„æˆå‘˜

- `length`å±æ€§ï¼šè¡¨ç¤ºå½“å‰æ•°ç»„çš„é•¿åº¦ã€‚
- `push`æ–¹æ³•ï¼šåŠ¨æ€çš„å‚¨å­˜ï¼ˆstorageï¼‰æ•°ç»„ä»¥åŠ`bytes`ç±»å‹ï¼ˆ`string`ç±»å‹ä¸å¯ä»¥ï¼‰éƒ½æœ‰ä¸€ä¸ª`push`æ–¹æ³•ï¼Œå®ƒç”¨æ¥æ·»åŠ æ–°çš„é›¶åˆå§‹åŒ–å…ƒç´ åˆ°æ•°ç»„æœ«å°¾ï¼Œå¹¶è¿”å›å…ƒç´ å¼•ç”¨ã€‚å› æ­¤å¯ä»¥è¿™æ ·`x.push().t = 2`æˆ–`x.push() = b`
- `push(x)`æ–¹æ³•ï¼šåŠ¨æ€çš„å‚¨å­˜ï¼ˆstorageï¼‰æ•°ç»„ä»¥åŠ`bytes`ç±»å‹ï¼ˆ`string`ç±»å‹ä¸å¯ä»¥ï¼‰éƒ½æœ‰ä¸€ä¸ª`push(x)`æ–¹æ³•ï¼Œç”¨æ¥åœ¨æ•°ç»„æœ«å°¾æ·»åŠ ä¸€ä¸ªç»™å®šçš„å…ƒç´ ï¼Œè¿™ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ã€‚
- `pop`æ–¹æ³•ï¼šåŠ¨æ€çš„å‚¨å­˜ï¼ˆstorageï¼‰æ•°ç»„ä»¥åŠ`bytes`ç±»å‹ï¼ˆ`string`ç±»å‹ä¸å¯ä»¥ï¼‰éƒ½æœ‰ä¸€ä¸ª`pop`æ–¹æ³•ï¼Œå®ƒå¯ä»¥ä»æ•°ç»„æœ«å°¾åˆ é™¤å…ƒç´ ã€‚åŒæ ·çš„ä¼šåœ¨ç§»é™¤å…ƒç´ ä¸Šéšå«è°ƒç”¨`delete`ã€‚
  æ³¨è§£ï¼š
- é€šè¿‡`push`å¢åŠ å‚¨å­˜æ•°ç»„çš„é•¿åº¦å…·æœ‰å›ºå®šçš„ gas æ¶ˆè€—ï¼Œå› ä¸ºå‚¨å­˜æ€»æ˜¯è¢«é›¶åˆå§‹åŒ–ï¼Œè€Œé€šè¿‡`pop`å‡å°‘é•¿åº¦åˆ™ä¾èµ–ç§»é™¤ä¸å…ƒç´ çš„å¤§å°ï¼ˆsizeï¼‰ã€‚å¦‚æœå…ƒç´ æ˜¯æ•°ç»„ï¼Œåˆ™æˆæœ¬æ˜¯å¾ˆé«˜çš„ï¼Œå› ä¸ºå®ƒåŒ…æ‹¬å·²åˆ é™¤çš„å…ƒç´ æ¸…ç†ï¼Œç±»ä¼¼äºåœ¨è¿™äº›å…ƒç´ ä¸Šè°ƒç”¨`delete`ã€‚
- å¦‚æœéœ€è¦åœ¨å¤–éƒ¨ï¼ˆexternalï¼‰å‡½æ•°ä¸­ä½¿ç”¨å¤šç»´æ•°ç»„ï¼Œè¿™éœ€è¦å¯ç”¨ ABI coder v2ã€‚å…±æœ‰ï¼ˆpublicï¼‰å‡½æ•°ä¸­æ˜¯æ”¯æŒä½¿ç”¨å¤šç»´æ•°ç»„çš„ã€‚

```sol
pragma solidity >=0.6.0 <0.9.0;

contract ArrayContract {
    uint[2**20] aLotOfIntegers;

    // æ³¨æ„ä¸‹é¢çš„ä»£ç å¹¶ä¸æ˜¯ä¸€å¯¹åŠ¨æ€æ•°ç»„ï¼Œ
    // è€Œæ˜¯ä¸€ä¸ªæ•°ç»„å…ƒç´ ä¸ºä¸€å¯¹å˜é‡çš„åŠ¨æ€æ•°ç»„ï¼ˆä¹Ÿå°±æ˜¯æ•°ç»„å…ƒç´ ä¸ºé•¿åº¦ä¸º 2 çš„å®šé•¿æ•°ç»„çš„åŠ¨æ€æ•°ç»„ï¼‰ã€‚
    // å› ä¸º  T[] æ€»æ˜¯ T çš„åŠ¨æ€æ•°ç»„, å°½ç®¡ T æ˜¯æ•°ç»„
    // æ‰€æœ‰çš„çŠ¶æ€å˜é‡çš„æ•°æ®ä½ç½®éƒ½æ˜¯ storage
    bool[2][] pairsOfFlags;

    // newPairs å­˜å‚¨åœ¨ memory ä¸­ (ä»…å½“å®ƒæ˜¯å…¬æœ‰çš„åˆçº¦å‡½æ•°)
    function setAllFlagPairs(bool[2][] memory newPairs) public {

     // å‘ä¸€ä¸ª storage çš„æ•°ç»„èµ‹å€¼ä¼šå¯¹ ``newPairs`` è¿›è¡Œæ‹·è´ï¼Œå¹¶æ›¿ä»£æ•´ä¸ª ``pairsOfFlags`` æ•°ç»„
        pairsOfFlags = newPairs;
    }

    struct StructType {
        uint[] contents;
        uint moreInfo;
    }
    StructType s;

    function f(uint[] memory c) public {
        // ä¿å­˜å¼•ç”¨
        StructType storage g = s;

        // åŒæ ·æ”¹å˜äº† ``s.moreInfo``.
        g.moreInfo = 2;

        // è¿›è¡Œäº†æ‹·è´ï¼Œå› ä¸º ``g.contents`` ä¸æ˜¯æœ¬åœ°å˜é‡ï¼Œè€Œæ˜¯æœ¬åœ°å˜é‡çš„æˆå‘˜
        g.contents = c;
    }

    function setFlagPair(uint index, bool flagA, bool flagB) public {
        // è®¿é—®ä¸å­˜åœ¨çš„ç´¢å¼•å°†å¼•å‘å¼‚å¸¸
        pairsOfFlags[index][0] = flagA;
        pairsOfFlags[index][1] = flagB;
    }

    function changeFlagArraySize(uint newSize) public {
       // ä½¿ç”¨ push å’Œ pop æ˜¯æ›´æ”¹æ•°ç»„é•¿åº¦çš„å”¯ä¸€æ–¹æ³•

        if (newSize < pairsOfFlags.length) {
            while (pairsOfFlags.length > newSize)
                pairsOfFlags.pop();
        } else if (newSize > pairsOfFlags.length) {
            while (pairsOfFlags.length < newSize)
                pairsOfFlags.push();
        }
    }

    function clear() public {
        // è¿™äº›å®Œå…¨æ¸…é™¤äº†æ•°ç»„
        delete pairsOfFlags;
        delete aLotOfIntegers;
        // æ•ˆæœç›¸åŒï¼ˆå’Œä¸Šé¢ï¼‰
        pairsOfFlags.length = new bool[2][](0);
    }

    bytes byteData;

    function byteArrays(bytes memory data) public {
        // å­—èŠ‚æ•°ç»„ï¼ˆbytesï¼‰ä¸ä¸€æ ·ï¼Œå®ƒä»¬åœ¨æ²¡æœ‰å¡«å……çš„æƒ…å†µä¸‹å­˜å‚¨ã€‚
        // å¯ä»¥è¢«è§†ä¸ºä¸ uint8 [] ç›¸åŒ
        byteData = data;
        for (uint i = 0; i < 7; i++)
            byteData.push();
        byteData[3] = 0x08;
        delete byteData[2];
    }

    function addFlag(bool[2] memory flag) public returns (uint) {
        pairsOfFlags.push(flag);
        return pairsOfFlags.length;
    }

    function createMemoryArray(uint size) public pure returns (bytes memory) {
        // ä½¿ç”¨`new`åˆ›å»ºåŠ¨æ€å†…å­˜æ•°ç»„ï¼š
        uint[2][] memory arrayOfPairs = new uint[2][](size);

        // å†…è”ï¼ˆInlineï¼‰æ•°ç»„å§‹ç»ˆæ˜¯é™æ€å¤§å°çš„ï¼Œå¦‚æœåªä½¿ç”¨å­—é¢å¸¸é‡ï¼Œåˆ™å¿…é¡»è‡³å°‘æä¾›ä¸€ç§ç±»å‹ã€‚
        arrayOfPairs[0] = [uint(1), 2];

        // åˆ›å»ºä¸€ä¸ªåŠ¨æ€å­—èŠ‚æ•°ç»„ï¼š
        bytes memory b = new bytes(200);
        for (uint i = 0; i < b.length; i++)
            b[i] = byte(uint8(i));
        return b;
    }
}
```

#### æ•°ç»„åˆ‡ç‰‡

æ•°ç»„åˆ‡ç‰‡æ˜¯æ•°ç»„è¿ç»­éƒ¨åˆ†çš„è§†å›¾ï¼Œç”¨æ³•å¦‚ï¼š`x[start:end]`ï¼Œ`start`å’Œ`end`æ˜¯ uint256 ç±»å‹ï¼ˆæˆ–ç»“æœä¸º uint256 çš„è¡¨è¾¾å¼ï¼‰ã€‚`x[start:end]`çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯`x[start]`ï¼Œæœ€åä¸€ä¸ªå…ƒç´ æ˜¯`x[end-1]`ã€‚
å¦‚æœ`start`æ¯”`end`å¤§æˆ–è€…`end`æ¯”æ•°ç»„é•¿åº¦è¿˜é•¿ï¼Œå°†ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
`start`å’Œ`end`éƒ½æ˜¯å¯é€‰çš„ï¼š`start`é»˜è®¤æ˜¯ 0ï¼Œè€Œ`end`é»˜è®¤æ˜¯æ•°ç»„é•¿åº¦ã€‚
æ•°ç»„åˆ‡ç‰‡æ²¡æœ‰ä»»ä½•æˆå‘˜ã€‚å®ƒä»¬å¯ä»¥éšå¼è½¬æ¢ä¸ºå…¶â€œèƒŒåâ€ç±»å‹çš„æ•°ç»„ï¼Œå¹¶æ”¯æŒç´¢å¼•è®¿é—®ã€‚ç´¢å¼•è®¿é—®ä¹Ÿæ˜¯ç›¸å¯¹äºåˆ‡ç‰‡çš„å¼€å§‹ä½ç½®ã€‚æ•°ç»„åˆ‡ç‰‡æ²¡æœ‰ç±»å‹åç§°ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰å˜é‡å¯ä»¥å°†æ•°ç»„åˆ‡ç‰‡ä½œä¸ºç±»å‹ï¼Œå®ƒä»¬ä»…å­˜åœ¨äºä¸­é—´è¡¨è¾¾å¼ä¸­ã€‚
ç›®å‰æ•°ç»„åˆ‡ç‰‡ï¼Œä»…å¯ä½¿ç”¨äº calldata æ•°ç»„ã€‚
æ•°ç»„åˆ‡ç‰‡åœ¨ ABI è§£ç æ•°æ®çš„æ—¶å€™éå¸¸æœ‰ç”¨ï¼Œæ¯”å¦‚ï¼š

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.5 <0.9.0;

contract Proxy {
    /// è¢«å½“å‰åˆçº¦ç®¡ç†çš„ å®¢æˆ·ç«¯åˆçº¦åœ°å€
    address client;

    constructor(address client_) {
        client = client_;
    }

    /// åœ¨è¿›è¡Œå‚æ•°éªŒè¯ä¹‹åï¼Œè½¬å‘åˆ°ç”±clientå®ç°çš„ "setOwner(address)"
    function forward(bytes calldata payload) external {
        bytes4 sig = bytes4(payload[:4]);

        // ç”±äºæˆªæ–­è¡Œä¸ºï¼Œä¸æ‰§è¡Œ bytes4(payload) æ˜¯ç›¸åŒçš„
        // bytes4 sig = bytes4(payload);

        if (sig == bytes4(keccak256("setOwner(address)"))) {
            address owner = abi.decode(payload[4:], (address));
            require(owner != address(0), "Address of owner cannot be zero.");
        }
        (bool status,) = client.delegatecall(payload);
        require(status, "Forwarded call failed.");
    }
}
```

#### ç»“æ„ä½“

Solidity æ”¯æŒé€šè¿‡ç»“æ„æ„é€ ä½“çš„å½¢å¼å®šä¹‰æ–°çš„ç±»å‹ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªç»“æ„ä½“ä½¿ç”¨çš„ç¤ºä¾‹ï¼š

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.6.0 <0.9.0;

// å®šä¹‰çš„æ–°ç±»å‹åŒ…å«ä¸¤ä¸ªå±æ€§ã€‚
// åœ¨åˆçº¦å¤–éƒ¨å£°æ˜ç»“æ„ä½“å¯ä»¥ä½¿å…¶è¢«å¤šä¸ªåˆçº¦å…±äº«ã€‚ åœ¨è¿™é‡Œï¼Œè¿™å¹¶ä¸æ˜¯çœŸæ­£éœ€è¦çš„ã€‚
struct Funder {
    address addr;
    uint amount;
}

contract CrowdFunding {

    // ä¹Ÿå¯ä»¥åœ¨åˆçº¦å†…éƒ¨å®šä¹‰ç»“æ„ä½“ï¼Œè¿™ä½¿å¾—å®ƒä»¬ä»…åœ¨æ­¤åˆçº¦å’Œè¡ç”Ÿåˆçº¦ä¸­å¯è§ã€‚
    struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {
        campaignID = numCampaigns++; // campaignID ä½œä¸ºä¸€ä¸ªå˜é‡è¿”å›

        // ä¸èƒ½ä½¿ç”¨ "campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)"
        // å› ä¸ºRHSï¼ˆright hand sideï¼‰ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å«æ˜ å°„çš„å†…å­˜ç»“æ„ä½“ "Campaign"
        Campaign storage c = campaigns[campaignID];
        c.beneficiary = beneficiary;
        c.fundingGoal = goal;
    }

    function contribute(uint campaignID) public payable {
        Campaign storage c = campaigns[campaignID];
        // ä»¥ç»™å®šçš„å€¼åˆå§‹åŒ–ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„ä¸´æ—¶ memory ç»“æ„ä½“ï¼Œ
        // å¹¶å°†å…¶æ‹·è´åˆ° storage ä¸­ã€‚
        // æ³¨æ„ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ Funder(msg.sender, msg.value) æ¥åˆå§‹åŒ–ã€‚
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) public returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}
```

æ³¨æ„åœ¨å‡½æ•°ä¸­ä½¿ç”¨ç»“æ„ä½“æ—¶ï¼Œä¸€ä¸ªç»“æ„ä½“æ˜¯å¦‚ä½•èµ‹å€¼ç»™ä¸€ä¸ªå‚¨å­˜ä½ç½®æ˜¯å‚¨å­˜ï¼ˆstorageï¼‰çš„å±€éƒ¨å˜é‡ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å¹¶æ²¡æœ‰æ‹·è´è¿™ä¸ªç»“æ„ä½“ï¼Œè€Œæ˜¯ä¿å­˜ä¸€ä¸ªå¼•ç”¨ï¼Œæ‰€ä»¥å¯¹å±€éƒ¨å˜é‡æˆå‘˜çš„èµ‹å€¼å®é™…ä¸Šä¼šè¢«å†™å…¥çŠ¶æ€ã€‚
å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥ç›´æ¥è®¿é—®ç»“æ„ä½“çš„æˆå‘˜è€Œä¸ç”¨å°†å…¶èµ‹å€¼ç»™ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œå°±åƒè¿™æ ·ï¼Œ`campaigns[campaignID].amount = 0`

### æ˜ å°„

æ˜ å°„ç±»å‹åœ¨å£°æ˜æ—¶çš„å½¢å¼ä¸º`mapping(KeyType => ValueType)`ã€‚å…¶ä¸­`KeyType`å¯ä»¥æ˜¯ä»»ä½•åŸºæœ¬ç±»å‹ï¼Œå³å¯ä»¥æ˜¯ä»»ä½•çš„å†…å»ºç±»å‹ï¼Œ`bytes`å’Œ`string`æˆ–åˆçº¦ç±»å‹ã€æšä¸¾ç±»å‹ã€‚è€Œå…¶ä»–ç”¨æˆ·å®šä¹‰çš„ç±»å‹æˆ–å¤æ‚çš„ç±»å‹å¦‚ï¼šæ˜ å°„ã€ç»“æ„ä½“ã€å³é™¤`bytes`å’Œ`string`ä¹‹å¤–çš„æ•°ç»„ç±»å‹æ˜¯ä¸å¯ä»¥ä½œä¸º`keyType`çš„ç±»å‹çš„ã€‚

`ValueType`å¯ä»¥æ˜¯åŒ…æ‹¬æ˜ å°„ç±»å‹åœ¨å†…çš„ç±»å‹ã€‚

æ˜ å°„å¯ä»¥è§†ä½œå“ˆå¸Œè¡¨ï¼Œå®ƒä»¬åœ¨å®é™…çš„åˆå§‹åŒ–è¿‡ç¨‹ä¸­åˆ›å»ºæ¯ä¸ªå¯èƒ½çš„ keyï¼Œå¹¶å°†å…¶æ˜ å°„åˆ°å­—èŠ‚å½¢å¼å…¨æ˜¯é›¶çš„å€¼ï¼šä¸€ä¸ªç±»å‹çš„é»˜è®¤å€¼ã€‚ç„¶è€Œä¸‹é¢æ˜¯æ˜ å°„ä¸å“ˆå¸Œè¡¨ä¸åŒçš„åœ°æ–¹ï¼šåœ¨æ˜ å°„ä¸­ï¼Œå®é™…å¹¶ä¸å­˜å‚¨ keyï¼Œè€Œæ˜¯å­˜å‚¨å®ƒçš„`keccak256`å“ˆå¸Œå€¼ï¼Œä»è€Œä¾¿äºæŸ¥è¯¢å®é™…çš„å€¼ã€‚
æ­£å› å¦‚æ­¤ï¼Œæ˜ å°„æ˜¯æ²¡æœ‰é•¿åº¦ï¼Œä¹Ÿæ²¡æœ‰ key çš„é›†åˆæˆ– value çš„é›†åˆçš„æ¦‚å¿µã€‚å› æ­¤å¦‚æœæ²¡æœ‰å…¶ä»–ä¿¡æ¯é”®çš„ä¿¡æ¯æ˜¯æ— æ³•è¢«åˆ é™¤çš„ã€‚
æ˜ å°„åªèƒ½æ˜¯**å­˜å‚¨ï¼ˆstorageï¼‰çš„æ•°æ®ä½ç½®**ï¼Œå› æ­¤åªå…è®¸ä½œä¸ºçŠ¶æ€å˜é‡æˆ–ä½œä¸ºå‡½æ•°å†…çš„å­˜å‚¨ï¼ˆstorageï¼‰å¼•ç”¨æˆ–ä½œä¸ºåº“å‡½æ•°çš„å‚æ•°ã€‚å®ƒä»¬ä¸èƒ½ç”¨åˆçº¦å…¬æœ‰å‡½æ•°çš„å‚æ•°æˆ–è¿”å›å€¼ã€‚
è¿™äº›é™åˆ¶åŒæ ·é€‚ç”¨äºåŒ…å«æ˜ å°„çš„æ•°ç»„å’Œç»“æ„ä½“ã€‚
å¯ä»¥å°†æ˜ å°„å£°æ˜ä¸º`public`ï¼Œç„¶åæ¥è®© Solidity åˆ›å»ºä¸€ä¸ª getter å‡½æ•°ã€‚KeyType å°†æˆä¸º getter çš„å¿…é¡»å‚æ•°ï¼Œå¹¶ä¸” getter ä¼šè¿”å› ValueTypeã€‚
å¦‚æœ ValueType æ˜¯ä¸€ä¸ªæ˜ å°„ã€‚è¿™æ—¶å†ä½¿ç”¨ getter æ—¶å°†éœ€è¦é€’å½’çš„ä¼ å…¥æ¯ä¸ª KeyType å‚æ•°ã€‚

åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œã€€ MappingExample ã€€åˆçº¦å®šä¹‰äº†ä¸€ä¸ªå…¬å…±ã€€ balances ã€€æ˜ å°„ï¼Œé”®ç±»å‹ä¸º addressï¼Œå€¼ç±»å‹ä¸º uintï¼Œ å°†ä»¥å¤ªåŠåœ°å€æ˜ å°„ä¸º æ— ç¬¦å·æ•´æ•°å€¼ã€‚ ç”±äºã€€ uint ã€€æ˜¯å€¼ç±»å‹ï¼Œå› æ­¤ getter è¿”å›ä¸è¯¥ç±»å‹åŒ¹é…çš„å€¼ï¼Œ å¯ä»¥åœ¨ã€€ MappingLBC ã€€åˆçº¦ä¸­çœ‹åˆ°åˆçº¦åœ¨æŒ‡å®šåœ°å€è¿”å›è¯¥å€¼ã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract MappingExample {
    mapping(address => uint) public balances;

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }
}

contract MappingLBC {
    function f() public returns (uint) {
        MappingExample m = new MappingExample();
        m.update(100);
        return m.balances(this);
    }
}
```

#### å¯è¿­ä»£æ˜ å°„

æ˜ å°„æœ¬èº«æ˜¯æ— æ³•éå†çš„ï¼Œå³æ— æ³•æšä¸¾æ‰€æœ‰çš„é”®ã€‚ä¸è¿‡ï¼Œå¯ä»¥åœ¨å®ƒä»¬ä¹‹ä¸Šå®ç°ä¸€ä¸ªæ•°æ®ç»“æ„æ¥è¿›è¡Œè¿­ä»£ã€‚
ä¾‹å¦‚ä»¥ä¸‹ä»£ç ï¼šå®ç°äº† IterableMapping åº“ï¼Œç„¶åã€€ User åˆçº¦å¯ä»¥æ·»åŠ æ•°æ®ï¼Œã€€ sum ã€€å‡½æ•°è¿­ä»£æ±‚å’Œæ‰€æœ‰å€¼ã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.8;

struct IndexValue { uint keyIndex; uint value; }
struct KeyFlag { uint key; bool deleted; }

struct itmap {
    mapping(uint => IndexValue) data;
    KeyFlag[] keys;
    uint size;
}

type Iterator is uint;

library IterableMapping {
    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {
        uint keyIndex = self.data[key].keyIndex;
        self.data[key].value = value;
        if (keyIndex > 0)
            return true;
        else {
            keyIndex = self.keys.length;

            self.keys.push();
            self.data[key].keyIndex = keyIndex + 1;
            self.keys[keyIndex].key = key;
            self.size++;
            return false;
        }
    }

    function remove(itmap storage self, uint key) internal returns (bool success) {
        uint keyIndex = self.data[key].keyIndex;
        if (keyIndex == 0)
            return false;
        delete self.data[key];
        self.keys[keyIndex - 1].deleted = true;
        self.size --;
    }

    function contains(itmap storage self, uint key) internal view returns (bool) {
        return self.data[key].keyIndex > 0;
    }

    function iterateStart(itmap storage self) internal view returns (Iterator) {
        return iteratorSkipDeleted(self, 0);
    }

    function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {
        return Iterator.unwrap(iterator) < self.keys.length;
    }

    function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {
        return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);
    }

    function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {
        uint keyIndex = Iterator.unwrap(iterator);
        key = self.keys[keyIndex].key;
        value = self.data[key].value;
    }

    function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {
        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)
            keyIndex++;
        return Iterator.wrap(keyIndex);
    }
}

// å¦‚ä½•ä½¿ç”¨
contract User {
    // Just a struct holding our data.
    itmap data;
    // Apply library functions to the data type.
    using IterableMapping for itmap;

    // Insert something
    function insert(uint k, uint v) public returns (uint size) {
        // This calls IterableMapping.insert(data, k, v)
        data.insert(k, v);
        // We can still access members of the struct,
        // but we should take care not to mess with them.
        return data.size;
    }

    // Computes the sum of all stored data.
    function sum() public view returns (uint s) {
        for (
            Iterator i = data.iterateStart();
            data.iterateValid(i);
            i = data.iterateNext(i)
        ) {
            (, uint value) = data.iterateGet(i);
            s += value;
        }
    }
}
```

### æ“ä½œç¬¦

å³ä½¿ä¸¤ä¸ªæ“ä½œæ•°çš„ç±»å‹ä¸ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œç®—æœ¯å’Œä½æ“ä½œè¿ç®—ã€‚ ä¾‹å¦‚ï¼Œä½ å¯ä»¥è®¡ç®—`y = x + z` ï¼Œå…¶ä¸­`x` æ˜¯ `uint8` ï¼Œ `z` æ˜¯ `int32` ç±»å‹ã€‚ åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œå°†ä½¿ç”¨ä»¥ä¸‹æœºåˆ¶æ¥ç¡®å®šè¿ç®—ç»“æœçš„ç±»å‹ï¼ˆè¿™åœ¨æº¢å‡ºçš„æƒ…å†µä¸‹å¾ˆé‡è¦ï¼‰ã€‚

1. å¦‚æœå³æ“ä½œæ•°çš„ç±»å‹å¯ä»¥éšå«åœ°è½¬æ¢ä¸ºå·¦æ“ä½œæ•°çš„ç±»å‹çš„ç±»å‹ï¼Œåˆ™ä½¿ç”¨å·¦æ“ä½œæ•°çš„ç±»å‹ã€‚
2. å¦‚æœå·¦æ“ä½œæ•°çš„ç±»å‹å¯ä»¥éšå«åœ°è½¬æ¢ä¸ºå³æ“ä½œæ•°çš„ç±»å‹çš„ç±»å‹ï¼Œåˆ™ä½¿ç”¨å³æ“ä½œæ•°çš„ç±»å‹ã€‚
3. å¦åˆ™ï¼Œè¯¥æ“ä½œä¸è¢«å…è®¸ã€‚
   å¦‚æœå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°æ˜¯ä¸€ä¸ª å¸¸é‡æ•°å­—ï¼Œä¼šé¦–å…ˆè¢«è½¬æ¢ä¸ºèƒ½å®¹çº³è¯¥å€¼çš„æœ€å°çš„ç±»å‹ (ç›¸åŒä½æ•°æ—¶ï¼Œæ— ç¬¦å·ç±»å‹è¢«è®¤ä¸ºæ¯”æœ‰ç¬¦å·ç±»å‹ â€œå°â€)ã€‚ å¦‚æœä¸¤è€…éƒ½æ˜¯å¸¸é‡æ•°å­—ï¼Œåˆ™ä»¥ä»»æ„çš„ç²¾åº¦è¿›è¡Œè®¡ç®—ã€‚
   æ“ä½œç¬¦çš„ç»“æœç±»å‹ä¸æ‰§è¡Œæ“ä½œçš„ç±»å‹ç›¸åŒï¼Œé™¤äº†æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œå…¶ç»“æœæ€»æ˜¯ `bool`ã€‚
   è¿ç®—ç¬¦ `**ï¼ˆå¹‚ï¼‰`ï¼Œ `<<` å’Œ `>>` ä½¿ç”¨å·¦è¾¹æ“ä½œæ•°çš„ç±»å‹æ¥ä½œä¸ºè¿ç®—ç»“æœç±»å‹ã€‚

#### ä¸‰å…ƒè¿ç®—ç¬¦

ä¸‰å…ƒè¿ç®—ç¬¦æ˜¯ä¸€ä¸ªè¡¨è¾¾æ˜¯å½¢å¼ï¼š `<expression> ? <trueExpression> : <falseExpression>` ã€‚ å®ƒæ ¹æ® `<expression>` çš„æ‰§è¡Œç»“æœï¼Œé€‰æ‹©åä¸¤ä¸ªç»™å®šè¡¨è¾¾å¼ä¸­çš„ä¸€ä¸ªã€‚ å¦‚æœ `<expression>` æ‰§è¡Œç»“æœ true ï¼Œé‚£ä¹ˆ `<trueExpression>` å°†è¢«æ‰§è¡Œï¼Œå¦åˆ™ `<falseExpression>` è¢«æ‰§è¡Œã€‚

ä¸‰å…ƒè¿ç®—ç¬¦çš„ç»“æœä¸ä¼šä¸ºæœ‰ç†æ•°ç±»å‹ï¼Œå³ä½¿å®ƒçš„æ‰€æœ‰æ“ä½œæ•°éƒ½æ˜¯æœ‰ç†æ•°ç±»å‹ã€‚ ç»“æœç±»å‹æ˜¯ç”±ä¸¤ä¸ªæ“ä½œæ•°çš„ç±»å‹å†³å®šçš„ï¼Œæ–¹æ³•ä¸ä¸Šé¢ä¸€æ ·ï¼Œå¦‚æœéœ€è¦çš„è¯ï¼Œé¦–å…ˆè½¬æ¢ä¸ºå®ƒä»¬çš„æœ€å°å¯å®¹çº³ç±»å‹ï¼ˆmobile type ï¼‰ã€‚

å› æ­¤ï¼Œ `255 + (true ? 1 : 0)` å°†ç”±äºç®—æœ¯æº¢å‡ºè€Œè¢«å›é€€ã€‚ åŸå› æ˜¯ `(true ? 1 : 0)` æ˜¯ `uint8` ç±»å‹ï¼Œè¿™è¿«ä½¿åŠ æ³•ä¹Ÿè¦åœ¨ `uint8` ä¸­æ‰§è¡Œã€‚ è€Œ 256 è¶…å‡ºäº†è¿™ä¸ªç±»å‹æ‰€å…è®¸çš„èŒƒå›´ã€‚

å¦ä¸€ä¸ªç»“æœæ˜¯ï¼Œåƒ `1.5 + 1.5` è¿™æ ·çš„è¡¨è¾¾å¼æ˜¯æœ‰æ•ˆçš„ï¼Œä½† `1.5 + (true ? 1.5 : 2.5)` åˆ™æ— æ•ˆã€‚ è¿™æ˜¯å› ä¸ºå‰è€…æ˜¯ä»¥æ— é™ç²¾åº¦æ¥è¿›è¡Œæœ‰ç†è¡¨è¾¾å¼è¿ç®—ï¼Œåªæœ‰å®ƒçš„æœ€ç»ˆç»“æœå€¼æ‰æ˜¯é‡è¦çš„ã€‚ åè€…æ¶‰åŠåˆ°å°†å°æ•°æœ‰ç†æ•°è½¬æ¢ä¸ºæ•´æ•°ï¼Œè¿™åœ¨ç›®å‰æ˜¯ä¸å…è®¸çš„ã€‚

#### å¤åˆæ“ä½œåŠè‡ªå¢è‡ªå‡æ“ä½œ

å¦‚æœ a æ˜¯ä¸€ä¸ª LValueï¼ˆå³ä¸€ä¸ªå˜é‡æˆ–è€…å…¶å®ƒå¯ä»¥è¢«èµ‹å€¼çš„ä¸œè¥¿ï¼‰ï¼Œä»¥ä¸‹è¿ç®—ç¬¦éƒ½å¯ä»¥ä½¿ç”¨ç®€å†™ï¼š
a += e ç­‰åŒäº a = a + eã€‚å…¶å®ƒè¿ç®—ç¬¦å¦‚ -=ï¼Œ \*=ï¼Œ /=ï¼Œ %=ï¼Œ |=ï¼Œ &= ï¼Œ ^= ï¼Œ <<= å’Œ >>= éƒ½æ˜¯å¦‚æ­¤å®šä¹‰çš„ã€‚ a++ å’Œ a-- åˆ†åˆ«ç­‰åŒäº a += 1 å’Œ a -= 1ï¼Œä½†è¡¨è¾¾å¼æœ¬èº«çš„å€¼ç­‰äº a åœ¨è®¡ç®—ä¹‹å‰çš„å€¼ã€‚ ä¸ä¹‹ç›¸åï¼Œ --a å’Œ ++a è™½ç„¶æœ€ç»ˆ a çš„ç»“æœä¸ä¹‹å‰çš„è¡¨è¾¾å¼ç›¸åŒï¼Œä½†è¡¨è¾¾å¼çš„è¿”å›å€¼æ˜¯è®¡ç®—ä¹‹åçš„å€¼ã€‚

#### delete

`delete a` çš„ç»“æœæ˜¯å°† a ç±»å‹åˆå§‹å€¼èµ‹å€¼ç»™ aã€‚å³å¯¹äºæ•´å‹å˜é‡æ¥è¯´ï¼Œç›¸å½“äº `a = 0`ï¼Œ`delete` ä¹Ÿé€‚ç”¨äºæ•°ç»„ï¼Œå¯¹äºåŠ¨æ€æ•°ç»„æ¥è¯´ï¼Œæ˜¯å°†é‡ç½®ä¸ºæ•°ç»„é•¿åº¦ä¸º 0 çš„æ•°ç»„ï¼Œè€Œå¯¹äºé™æ€æ•°ç»„æ¥è¯´ï¼Œæ˜¯å°†æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ é‡ç½®ä¸ºåˆå§‹å€¼ã€‚å¯¹æ•°ç»„è€Œè¨€ï¼Œ `delete a[x]` ä»…åˆ é™¤æ•°ç»„ç´¢å¼• x å¤„çš„å…ƒç´ ï¼Œå…¶ä»–çš„å…ƒç´ å’Œé•¿åº¦ä¸å˜ï¼Œè¿™ä»¥ä¸ºç€æ•°ç»„ä¸­ç•™å‡ºäº†ä¸€ä¸ªç©ºä½ã€‚å¦‚æœæ‰“ç®—åˆ é™¤é¡¹ï¼Œæ˜ å°„å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚

å¦‚æœå¯¹è±¡ `a` æ˜¯ç»“æ„ä½“ï¼Œåˆ™å°†ç»“æ„ä½“ä¸­çš„æ‰€æœ‰å±æ€§(æˆå‘˜)é‡ç½®ã€‚

æ¢å¥è¯è¯´ï¼Œåœ¨ `delete a` ä¹‹å a çš„å€¼ä¸åœ¨æ²¡æœ‰èµ‹å€¼çš„æƒ…å†µä¸‹å£°æ˜ a çš„æƒ…å†µç›¸åŒï¼Œ ä½†éœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š

- `delete` å¯¹æ•´ä¸ªæ˜ å°„æ˜¯æ— æ•ˆçš„ï¼ˆå› ä¸ºæ˜ å°„çš„é”®å¯ä»¥æ˜¯ä»»æ„çš„ï¼Œé€šå¸¸ä¹Ÿæ˜¯æœªçŸ¥çš„ï¼‰ã€‚ å› æ­¤åœ¨ä½ åˆ é™¤ä¸€ä¸ªç»“æ„ä½“æ—¶ï¼Œç»“æœå°†é‡ç½®æ‰€æœ‰çš„éæ˜ å°„å±æ€§ï¼ˆæˆå‘˜ï¼‰ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯é€’å½’è¿›è¡Œçš„ï¼Œé™¤éå®ƒä»¬æ˜¯æ˜ å°„ã€‚ ç„¶è€Œï¼Œå•ä¸ªçš„é”®åŠå…¶æ˜ å°„çš„å€¼æ˜¯å¯ä»¥è¢«åˆ é™¤çš„ã€‚

ç†è§£ `delete a` çš„æ•ˆæœå°±åƒæ˜¯ç»™ a èµ‹å€¼å¾ˆé‡è¦ï¼Œæ¢å¥è¯è¯´ï¼Œè¿™ç›¸å½“äºåœ¨ a ä¸­å­˜å‚¨äº†ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚

å½“ a æ˜¯åº”ç”¨å˜é‡æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™ä¸ªåŒºåˆ«ï¼Œ `delete a` å®ƒåªä¼šé‡ç½® a æœ¬èº«ï¼Œè€Œä¸æ˜¯æ›´æ”¹å®ƒä¹‹å‰å¼•ç”¨çš„å€¼ã€‚

```sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.0 <0.9.0;

contract DeleteLBC {
    uint data;
    uint[] dataArray;

    function f() public {
        uint x = data;
        delete x; // å°† x è®¾ä¸º 0ï¼Œå¹¶ä¸å½±å“æ•°æ®
        delete data; // å°† data è®¾ä¸º 0ï¼Œå¹¶ä¸å½±å“ xï¼Œå› ä¸ºå®ƒä»ç„¶æœ‰ä¸ªå‰¯æœ¬
        uint[] storage y = dataArray;
        delete dataArray;
        // å°† dataArray.length è®¾ä¸º 0ï¼Œä½†ç”±äº uint[] æ˜¯ä¸€ä¸ªå¤æ‚çš„å¯¹è±¡ï¼Œy ä¹Ÿå°†å—åˆ°å½±å“ï¼Œ
        // å› ä¸ºå®ƒæ˜¯ä¸€ä¸ªå­˜å‚¨ä½ç½®æ˜¯ storage çš„å¯¹è±¡çš„åˆ«åã€‚
        // å¦ä¸€æ–¹é¢ï¼š"delete y" æ˜¯éæ³•çš„ï¼Œå¼•ç”¨äº† storage å¯¹è±¡çš„å±€éƒ¨å˜é‡åªèƒ½ç”±å·²æœ‰çš„ storage å¯¹è±¡èµ‹å€¼ã€‚
        assert(y.length == 0);
    }
}
```

### åŸºæœ¬ç±»å‹ä¹‹é—´çš„è½¬æ¢

#### éšå¼è½¬æ¢
åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è¿›è¡Œéšå¼ç±»å‹è½¬æ¢ï¼Œ è¿™äº›æƒ…å†µåŒ…æ‹¬: åœ¨èµ‹å€¼, å‚æ•°ä¼ é€’ç»™å‡½æ•°ä»¥åŠåº”ç”¨è¿ç®—ç¬¦æ—¶ã€‚ é€šå¸¸ï¼Œå¦‚æœå¯ä»¥è¿›è¡Œå€¼ç±»å‹ä¹‹é—´çš„éšå¼è½¬æ¢ï¼Œ å¹¶ä¸”ä¸ä¼šä¸¢å¤±ä»»ä½•ä¿¡æ¯ã€‚ éƒ½æ˜¯å¯ä»¥éšå¼ç±»å‹è½¬æ¢
ä¾‹å¦‚, `uint8` å¯ä»¥è½¬æ¢æˆ `uint16`ï¼Œ `int128` è½¬æ¢æˆ `int256`ï¼Œä½† `int8` ä¸èƒ½è½¬æ¢æˆ `uint256` ï¼ˆå› ä¸º `uint256` ä¸èƒ½æ¶µç›–æŸäº›å€¼ï¼Œä¾‹å¦‚ï¼Œ -1ï¼‰ã€‚
å¦‚æœå°†è¿ç®—ç¬¦åº”ç”¨äºä¸åŒçš„ç±»å‹ï¼Œåˆ™ç¼–è¯‘å™¨å°†å°è¯•å°†å…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°éšå¼è½¬æ¢ä¸ºå¦ä¸€ä¸ªæ“ä½œæ•°çš„ç±»å‹ï¼ˆèµ‹å€¼ä¹Ÿæ˜¯å¦‚æ­¤ï¼‰ã€‚ è¿™æ„å‘³ç€æ“ä½œå§‹ç»ˆä»¥æ“ä½œæ•°ä¹‹ä¸€çš„ç±»å‹æ‰§è¡Œã€‚

#### æ˜¾ç¤ºè½¬æ¢


## å•ä½å’Œå…¨å±€å˜é‡

### ä»¥å¤ªå¸ï¼ˆEtherï¼‰å•ä½

### æ—¶é—´å•ä½

### ç‰¹æ®Šå˜é‡å’Œå‡½æ•°

## è¡¨è¾¾å¼å’Œæ§åˆ¶ç»“æ„

### æ§åˆ¶ç»“æ„

### å‡½æ•°è°ƒç”¨

### é€šè¿‡ new åˆ›å»ºåˆçº¦

### è¡¨è¾¾å¼è®¡ç®—é¡ºåº

### èµ‹å€¼

### ä½œç”¨åŸŸå’Œå£°æ˜

### ç®—æœ¯è¿ç®—çš„æ£€æŸ¥æ¨¡å¼ä¸éæ£€æŸ¥æ¨¡å¼

### é”™è¯¯å¤„ç†åŠå¼‚å¸¸ï¼šAssert,Require,Revert

## åˆçº¦

### åˆ›å»ºåˆçº¦

### å¯è§æ€§å’Œ getter å‡½æ•°

### å‡½æ•°ä¿®æ”¹å™¨ï¼ˆmodifierï¼‰

### Constant å’Œ Immutable çŠ¶æ€å˜é‡

### å‡½æ•°

### äº‹ä»¶ Events

### é”™è¯¯å’Œå›é€€è¯­å¥

### ç»§æ‰¿

### æŠ½è±¡åˆçº¦

### æ¥å£

### åº“

### Using For

## å†…è”æ±‡ç¼–

## [é€ŸæŸ¥è¡¨](https://learnblockchain.cn/docs/solidity/cheatsheet.html#order)

## è¯­è¨€è¯­æ³•

# ç¼–è¯‘å™¨

## ä½¿ç”¨ç¼–è¯‘å™¨

## Analysing the Compiler Output

## Solidity IR-based Codegen Changes

# æ·±å…¥ SOLIDITY å†…éƒ¨

## çŠ¶æ€å˜é‡åœ¨å‚¨å­˜ä¸­å¸ƒå±€

### æ˜ å°„å’ŒåŠ¨æ€æ•°ç»„

### JSON è¾“å‡º

## å˜é‡åœ¨å†…å­˜å¸ƒå±€

### ä¸å‚¨å­˜ä¸­å¸ƒå±€çš„ä¸åŒ

## Call Data å¸ƒå±€

## æ¸…ç†å˜é‡

## Source Mappings

## The Optimizer

### Benefits of Optimizing Solidity Code

### Differences between Optimized and Non-Optimized Code

### Optimizer Parameter Runs

### Opcode-Based Optimizer Module

### Yul-Based Optimizer Module

## åˆçº¦çš„å…ƒæ•°æ®

## åº”ç”¨äºŒè¿›åˆ¶æ¥å£è¯´æ˜

# è¡¥å……ææ–™

## é‡å¤§æ›´æ–°

## NatSpecï¼ˆæ³¨é‡Šæè¿°ï¼‰è§„èŒƒ

## å®‰å…¨è€ƒé‡

## SMTChecker å’Œå½¢å¼åŒ–éªŒè¯

## èµ„æº

## Import Path Resolution

## Yul

## ç¼–ç¨‹é£æ ¼æŒ‡å—

## é€šç”¨æ¨¡å¼

## å·²çŸ¥ bug åˆ—è¡¨

<https://learnblockchain.cn/docs/solidity/bugs.html>

# ç›¸å…³æ–‡æ¡£

## [Hardhat ä¸­æ–‡æ–‡æ¡£](https://learnblockchain.cn/docs/hardhat/getting-started/)

## [Ether.js ä¸­æ–‡æ–‡æ¡£](https://learnblockchain.cn/docs/ethers.js/)

## [Web3.js ä¸­æ–‡æ–‡æ¡£](https://learnblockchain.cn/docs/web3.js/)

## [Truffle ä¸­æ–‡æ–‡æ¡£](https://learnblockchain.cn/docs/truffle/)
